<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Models · GATlab.jl</title><meta name="title" content="Symbolic Models · GATlab.jl"/><meta property="og:title" content="Symbolic Models · GATlab.jl"/><meta property="twitter:title" content="Symbolic Models · GATlab.jl"/><meta name="description" content="Documentation for GATlab.jl."/><meta property="og:description" content="Documentation for GATlab.jl."/><meta property="twitter:description" content="Documentation for GATlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GATlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../catlab_differences/">Changes from Catlab GATs</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../theories/">Theories</a></li><li><a class="tocitem" href="../models/">Models and instances</a></li><li class="is-active"><a class="tocitem" href>Symbolic Models</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li><li><a class="tocitem" href="../../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Concepts</a></li><li class="is-active"><a href>Symbolic Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/concepts/symbolic_models.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Models"><a class="docs-heading-anchor" href="#Symbolic-Models">Symbolic Models</a><a id="Symbolic-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Models" title="Permalink"></a></h1><p>Theories can also be instantiated as systems of symbolic expressions, using the <a href="../../api/#GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}"><code>@symbolic_model</code></a> macro. The symbolic expressions are expression trees, as commonly used in computer algebra systems. They are similar to Julia&#39;s <code>Expr</code> type but they are instead subtyped from GATlab&#39;s <a href="../../api/#GATlab.Models.SymbolicModels.GATExpr"><code>GATExpr</code></a> type and they have a more refined type hierarchy.</p><p>A single theory can have different syntax systems, treating different terms as primitive or performing different simplication or normalization procedures. GATlab tries to make it easy to define new syntax systems. Many of the theories included with GATlab have default syntax systems, but the user is encouraged to define their own to suit their needs.</p><p>To get started, you can always call the <code>@symbolic_model</code> macro with an empty body. Below, we subtype from GATlab&#39;s abstract types <code>ObExpr</code> and <code>HomExpr</code> to enable LaTeX pretty-printing and other convenient features, but this is not required.</p><pre><code class="language-julia hljs">@symbolic_model CategoryExprs{ObExpr, HomExpr} ThCategory begin
end
A, B, C, D = [ Ob(CategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)
compose(compose(f,g),h)</code></pre><p>The resulting symbolic expressions perform no simplification. For example, the associativity law is not satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><p>Thus, unlike instances of a theory, syntactic expressions are not expected to obey all the axioms of the theory.</p><p>However, the user may supply logic in the body of the <code>@symbolic_model</code> macro to enforce the axioms or perform other kinds of simplification. Below, we use the <code>associate</code> function provided by GATlab to convert the binary expressions representing composition into <span>$n$</span>-ary expressions for any number <span>$n$</span>. The option <code>strict=true</code> tells GATlab to check that the domain and codomain objects are strictly equal and throw an error if they are not.</p><pre><code class="language-julia hljs">@symbolic_model SimplifyingCategoryExprs{ObExpr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate(new(f,g; strict=true))
end
A, B, C, D = [ Ob(SimplifyingCategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]
f, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)
compose(compose(f,g),h)</code></pre><p>Now the associativity law <em>is</em> satisfied:</p><pre><code class="language-julia hljs">compose(compose(f,g),h) == compose(f,compose(g,h))</code></pre><h3 id="Primitive-versus-derived-operations"><a class="docs-heading-anchor" href="#Primitive-versus-derived-operations">Primitive versus derived operations</a><a id="Primitive-versus-derived-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-versus-derived-operations" title="Permalink"></a></h3><p>In some algebraic structures, there is a choice as to which operations should be considered primitive and which should be derived. For example, in a <a href="https://ncatlab.org/nlab/show/cartesian+monoidal+category">cartesian monoidal category</a>, the copy operation <span>$\Delta_X: X \to X \otimes X$</span> can be defined in terms of the pairing operation <span>$\langle f, g \rangle$</span>, or vice versa. In addition, the projections <span>$\pi_{X,Y}: X \otimes Y \to X$</span> and <span>$\pi_{X,Y}&#39;: X \otimes Y \to Y$</span> can be defined in terms of the deleting operation (terminal morphism) or left as primitive.</p><p>In GATlab, the recommended way to deal with such situations is to define <em>all</em> the operations in the theory and then allow particular syntax systems to determine which operations, if any, will be derived from others. In the case of the cartesian monoidal category, we could define a signature <code>CartesianCategory</code> by inheriting from the builtin theory <code>SymmetricMonoidalCategory</code>.</p><pre><code class="language-julia hljs">using GATlab</code></pre><pre><code class="language-julia hljs">@signature ThCartesianCategory &lt;: ThSymmetricMonoidalCategory begin
  mcopy(A::Ob)::(A → (A ⊗ A))
  delete(A::Ob)::(A → munit())
  pair(f::(A → B), g::(A → C))::(A → (B ⊗ C)) ⊣ (A::Ob, B::Ob, C::Ob)
  proj1(A::Ob, B::Ob)::((A ⊗ B) → A)
  proj2(A::Ob, B::Ob)::((A ⊗ B) → B)
end
nothing # hide</code></pre><p>We could then define the copying operation in terms of the pairing.</p><pre><code class="language-julia hljs">@symbolic_model CartesianCategoryExprsV1{ObExpr,HomExpr} ThCartesianCategory begin
  mcopy(A::Ob) = pair(id(A), id(A))
end
A = Ob(CartesianCategoryExprsV1.Ob, :A)
mcopy(A)</code></pre><p>Alternatively, we could define the pairing and projections in terms of the copying and deleting operations.</p><pre><code class="language-julia hljs">@symbolic_model CartesianCategoryExprsV2{ObExpr,HomExpr} ThCartesianCategory begin
  pair(f::Hom, g::Hom) = compose(mcopy(dom(f)), otimes(f,g))
  proj1(A::Ob, B::Ob) = otimes(id(A), delete(B))
  proj2(A::Ob, B::Ob) = otimes(delete(A), id(B))
end
A, B, C = [ Ob(CartesianCategoryExprsV2.Ob, X) for X in [:A, :B, :C] ]
f, g = Hom(:f, A, B), Hom(:g, A, C)
pair(f, g)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models and instances</a><a class="docs-footer-nextpage" href="../../api/">Library Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 11 March 2024 20:26">Monday 11 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
