<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theories · GATlab.jl</title><meta name="title" content="Theories · GATlab.jl"/><meta property="og:title" content="Theories · GATlab.jl"/><meta property="twitter:title" content="Theories · GATlab.jl"/><meta name="description" content="Documentation for GATlab.jl."/><meta property="og:description" content="Documentation for GATlab.jl."/><meta property="twitter:description" content="Documentation for GATlab.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GATlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../catlab_differences/">Changes from Catlab GATs</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li class="is-active"><a class="tocitem" href>Theories</a><ul class="internal"><li><a class="tocitem" href="#What-is-a-GAT?"><span>What is a GAT?</span></a></li><li><a class="tocitem" href="#The-@theory-macro"><span>The <code>@theory</code> macro</span></a></li></ul></li><li><a class="tocitem" href="../models/">Models and instances</a></li><li><a class="tocitem" href="../symbolic_models/">Symbolic Models</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li><li><a class="tocitem" href="../../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Concepts</a></li><li class="is-active"><a href>Theories</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theories</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/concepts/theories.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Theories"><a class="docs-heading-anchor" href="#Theories">Theories</a><a id="Theories-1"></a><a class="docs-heading-anchor-permalink" href="#Theories" title="Permalink"></a></h1><h2 id="What-is-a-GAT?"><a class="docs-heading-anchor" href="#What-is-a-GAT?">What is a GAT?</a><a id="What-is-a-GAT?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-GAT?" title="Permalink"></a></h2><p>Generalized Algebraic Theories (GATs) are the backbone of GATlab so let&#39;s expand a bit on GATs and how they fit into the bigger picture of algebra.</p><p>An algebraic structure, like a group or category, is a mathematical object whose axioms all take the form of equations that are universally quantified (the equations have no exceptions). That’s not a formal definition but it’s a good heuristic. There are different ways to make this precise. The oldest, going back to universal algebra in the early 20th centrury, are algebraic theories.</p><p><a href="https://en.wikipedia.org/wiki/Universal_algebra">Universal algebra</a> (sometimes called general algebra) is the field of mathematics that studies algebraic structures themselves, not examples (&quot;models&quot;) of algebraic structures. For instance, rather than take particular groups as the object of study, in universal algebra one takes the class of groups as an object of study. In an algebraic theory, you have a collection of (total) operations and they obey a set of equational axioms. Classically, there is only a single generating type, but there are also typed or multi-sorted versions of algebraic theories. Most of the classical structures of abstract algebra, such as groups, rings, and modules, can be defined as algebraic theories.</p><p>Importantly, the theory of categories is <a href="https:// mathoverflow.net/q/354920">not algebraic</a>. In other words, a category cannot be defined as a (multi-sorted) algebraic theory. The reason is that the operation of composition is partial, since you can only compose morphisms with compatible (co)domains. Now, categories sure feel like algebraic structures, so people have come up with generalizations of algebraic theories that accomodate categories and related structures.</p><p>The first of these was Freyd’s essentially algebraic theories. In an essentially algebraic theory, you can have partially defined operations; however, to maintain the equational character of the system, the domains of operations must themselves be defined equationally. For example, the theory of categories would be defined as having two types, Ob and Hom, and the composition operation <code>compose(f::Hom,g::Hom)::Hom</code> would have domain given by the equation <code>codom(f) == dom(g)</code>. As your theories get more elaborate, the sets of equations defining the domains get more complicated and reasoning about the structure is overwhelming.</p><p>Later, Cartmell proposed generalized algebraic theories, which solves the same problem but in a different way. Rather than having partial operations, you have total operations but on dependent types (types that are parameterized by values). So now the composition operation has signature <code>compose(f::Hom(A,B), g::Hom(B,C))::Hom(A,C) ⊣ [A::Ob, B::Ob, C::Ob]</code>  exactly as appears in GATlab. This is closer to the way that mathematicians actually think and write about categories. For example, if you look at the definitions of category, functor, and natural transformation in <a href="http://www.math.jhu.edu/ ~eriehl/context/">Emily Riehl’s textbook</a>, you will see that they are already essentially in the form of a GAT, whereas they require translation into an essentially algebraic theory. Nevertheless, GATs and essentially algebraic theories have the same expressive power, at least in their standard set-based semantics. GATs provide a version of the computer scientist&#39;s type theory that plays well with the mathematician&#39;s algebra, thus, providing a perfect opportunity for computer algebra systems.</p><h2 id="The-@theory-macro"><a class="docs-heading-anchor" href="#The-@theory-macro">The <code>@theory</code> macro</a><a id="The-@theory-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@theory-macro" title="Permalink"></a></h2><p>GATlab implements a version of the GAT formalism on top of Julia&#39;s type system, taking advantage of Julia macros to provide a pleasant syntax. GATs are defined using the <code>@theory</code> macro.</p><p>For example, the theory of categories could be defined by:</p><pre><code class="language-julia hljs">@theory ThCategory begin
  @op begin
    (→) := Hom
    (⋅) := compose
  end
  Ob::TYPE
  Hom(dom::Ob, codom::Ob)::TYPE
  id(A::Ob)::(A → A)
  compose(f::(A → B), g::(B → C))::(A → C) ⊣ [A::Ob, B::Ob, C::Ob]
  (f ⋅ g) ⋅ h == f ⋅ (g ⋅ h) ⊣ [A::Ob, B::Ob, C::Ob, D::Ob,
                                f::(A → B), g::(B → C), h::(C → D)]
  f ⋅ id(B) == f ⊣ [A::Ob, B::Ob, f::(A → B)]
  id(A) ⋅ f == f ⊣ [A::Ob, B::Ob, f::(A → B)]
end</code></pre><p>The code is simplified only slightly from the official GATlab definition of <code>ThCategory</code>. The theory has two <em>type constructors</em>, <code>Ob</code> (object) and <code>Hom</code> (morphism). The type <code>Hom</code> is a dependent type, depending on two objects, named <code>dom</code> (domain) and <code>codom</code> (codomain). The theory has two <em>term constructors</em>, <code>id</code> (identity) and <code>compose</code> (composition).</p><p>Notice how the return types of the term constructors depend on the argument values. For example, the term <code>id(A)</code> has type <code>Hom(A,A)</code>. The term constructor <code>compose</code> also uses <em>context variables</em>, listed to the right of the <code>⊣</code> symbol. These context variables can also be defined after a <code>where</code> clause, but the left hand side must be surrounded by parentheses. This allows us to write <code>compose(f,g)</code>, instead of the more verbose <code>compose(A,B,C,f,g)</code> (for discussion, see Cartmell, 1986, Sec 10: Informal syntax).</p><p>Notice the <code>@op</code> call where we can create method aliases that can then be used throughout the rest of the theory and outside of definition. We can either use this block notation, or a single line notation such as <code>@op (⋅) := compose</code> to define a single alias. Here we utilize this functionality by replacing the <code>Hom</code> and <code>compose</code> methods with their equivalent Unicode characters, <code>→</code> and <code>⋅</code> respectively. These aliases are also automatically available to definitions that inherit a theory that already has the alias defined.</p><p>The result of the <code>@theory</code> macro is a module with the following members:</p><ol><li><p>For each <em>declaration</em> in the theory (which includes term constructors, type constructors, arguments to type constructors (i.e. accessors like <code>dom</code> and <code>codom</code>), and aliases of the above), a function named with the name of the declaration. These functions are not necessarily original to this module; they may be imported. This allows us to, for instance, use <code>Base.+</code> as a method for a theory. For instance, <code>ThCategory</code> has functions <code>Ob, Hom, dom, codom, compose, id, ⋅, →</code>.</p></li><li><p>A submodule called <code>Meta</code> with members:</p></li></ol><ul><li><code>T</code>: a zero-field struct that serves as a type-level signifier for the theory.</li><li><code>theory</code>: a constant of type <code>GAT</code> which stores the data of the theory.</li><li><code>@theory</code>: a macro which expands directly to <code>theory</code>, which is used to pass around the data of the theory at macro-expand time.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general, a GAT consists of a <em>signature</em>, defining the types and terms of the theory, and a set of <em>axioms</em>, the equational laws satisfied by models of the theory. The theory of categories, for example, has axioms of unitality and associativity. At present, GATlab supports the specification of both signatures and the axioms, but only uses the axioms as part of  rewriting via e-graphs: it is not automatically checked that models of a GAT satisfy the axioms. It is the responsibility of the programmer to ensure this.</p></div></div><h4 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h4><ul><li>Cartmell, 1986: Generalized algebraic theories and contextual categories, <a href="https://doi.org/10.1016/0168-0072(86)90053-9">DOI:10.1016/0168-0072(86)90053-9</a></li><li>Cartmell, 1978, PhD thesis: <em>Generalized algebraic theories and contextual categories</em></li><li>Pitts, 1995: Categorical logic, Sec 6: Dependent types</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scopes/">« Scopes</a><a class="docs-footer-nextpage" href="../models/">Models and instances »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Saturday 2 December 2023 00:19">Saturday 2 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
