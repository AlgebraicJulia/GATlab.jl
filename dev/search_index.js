var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [Gatlab,\n  Gatlab.Util,\n  Gatlab.Util.Names,\n  Gatlab.Syntax,\n  Gatlab.Syntax.Theories,\n  Gatlab.Syntax.TheoryMaps,\n  Gatlab.Syntax.Pushouts,\n  Gatlab.Syntax.Visualization,\n  Gatlab.Logic,\n  Gatlab.Logic.EGraphs,\n  Gatlab.Logic.EMatching,\n  Gatlab.Models,\n  Gatlab.Models.ModelInterface,\n  Gatlab.Dsl,\n  ]","category":"page"},{"location":"api/#Gatlab.Util.Names.Name","page":"Library Reference","title":"Gatlab.Util.Names.Name","text":"Names are used to label parts of a GAT.\n\nThey are used for both human input and output of a GAT, but are not used internally.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Util.Names.SymLit","page":"Library Reference","title":"Gatlab.Util.Names.SymLit","text":"We have a symbol wrapper because we get symbols from parsing, and it is faster to compare symbols than it is to compare strings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.AbstractTheory","page":"Library Reference","title":"Gatlab.Syntax.Theories.AbstractTheory","text":"A type-level signifier for a particular theory, used to control dispatch and to pass around theory objects (which can't be type parameters) at the type level.\n\nStructs which subtype AbstractTheory should always be singletons, and have theory defined on them.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.AnonTrmTag","page":"Library Reference","title":"Gatlab.Syntax.Theories.AnonTrmTag","text":"This can be used when there isn't a specific struct like Category.compose. Specific structs are preferred because they make reading backtraces easier.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.AnonTypTag","page":"Library Reference","title":"Gatlab.Syntax.Theories.AnonTypTag","text":"This can be used when there isn't a specific struct like Category.Ob. Specific structs are preferred because they make reading backtraces easier.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.FullContext","page":"Library Reference","title":"Gatlab.Syntax.Theories.FullContext","text":"The full context for a Trm or Typ consists of both the list of judgments in the theory, and also the list of judgments in the context.\n\nTODO: maybe we should have different terms for \"context judgment\" and \"theory judgment\"\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.Lvl","page":"Library Reference","title":"Gatlab.Syntax.Theories.Lvl","text":"The tag of a Lvl takes up two bits and can be three things:\n\n00: part of the theory 01: part of the context 10: part of the argument to a dependent context\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.TrmTag","page":"Library Reference","title":"Gatlab.Syntax.Theories.TrmTag","text":"This is used as a supertype for the tag types in a theory that correspond to term constructors.\n\nExample:\n\nmodule Category\nstruct compose <: TrmTag{3} end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.Typ","page":"Library Reference","title":"Gatlab.Syntax.Theories.Typ","text":"The head of a type can never come from a context, only a theory, because it  should point at a type constructor judgment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.TypArgTag","page":"Library Reference","title":"Gatlab.Syntax.Theories.TypArgTag","text":"This is used as a supertype for the tag types in a theory that correspond to the arguments to type constructors\n\nExample:\n\nmodule Category\nstruct dom <: TypArgTag{2,1} end\nstruct codom <: TypArgTag{2,2} end\n\nThe first argument is the index of the type constructor, the second is the index of the argument.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.TypTag","page":"Library Reference","title":"Gatlab.Syntax.Theories.TypTag","text":"This is used as a supertype for the tag types in a theory that correspond to type constructors.\n\nExample:\n\nmodule Category\nstruct Ob <: TypTag{1} end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Theories.gettheory","page":"Library Reference","title":"Gatlab.Syntax.Theories.gettheory","text":"Meant to be overloaded as\n\ngettheory(::T) = ...\n\nwhere T is a singleton struct subtyping AbstractTheory\n\nReturns the @ref(Theory) associated to T.\n\n\n\n\n\n","category":"function"},{"location":"api/#Gatlab.Syntax.Theories.gettheory-Tuple{Type{<:AbstractTheory}}","page":"Library Reference","title":"Gatlab.Syntax.Theories.gettheory","text":"A convenience overload of theory\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Theories.lookup-Tuple{FullContext, Name}","page":"Library Reference","title":"Gatlab.Syntax.Theories.lookup","text":"Get the Lvl corresponding to a Name. This is the most recent judgment with that name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Context}","page":"Library Reference","title":"Gatlab.Syntax.TheoryMaps.TheoryMap","text":"Map a context in the domain theory into a context of the codomain theory\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Gatlab.Syntax.Theories.TrmTyp}","page":"Library Reference","title":"Gatlab.Syntax.TheoryMaps.TheoryMap","text":"Suppose dom(f) is [X,Y,Z,P,Q] and codom(f) is [XX,ϕ,ψ] suppose we have a term: P(a,Q(b,c)) ⊢ a::X,b::Y,c::Z i.e. 4({1},5({2},{3}))\n\nf maps all sorts to XX f maps {P(x,y) ⊢ x::X,y::Y} to ϕ(ψ(y),x) i.e. 2(3({2}),{1}) and {Q(u,w) ⊢ u::Y,w::Z}    to ψ(w)      i.e. 3({2})\n\nWe should our term translate first to ϕ(ψ(y),x)  i.e.  2(3({2}),{1})\n\nand then substitute x (i.e. {1}) for the mapped first argument  y (i.e. 5) for f(q(b,c)) i.e. ϕ(ψ(ψ(c)),x) 2(3(3({3})),{1})\n\nSo f(4({1},5({2},{3}))) = 2(3(3({3})),{1})\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Pushouts.pushout-Tuple{Name, TheoryIncl, TheoryIncl}","page":"Library Reference","title":"Gatlab.Syntax.Pushouts.pushout","text":"Pushout two inclusions.      f   A ↪ B  g ↓   ↓   C->⌜D\n\nD is a copy of B with the novel judgments of C added aftewards.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Pushouts.substitute_level-Tuple{Judgment, Vector{Int64}}","page":"Library Reference","title":"Gatlab.Syntax.Pushouts.substitute_level","text":"v is a FinFunction from old de bruijn levels to new ones. Its domain is the  size of the theory of the judgment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Visualization.Sequent","page":"Library Reference","title":"Gatlab.Syntax.Visualization.Sequent","text":"Intermediate representation of a judgment for pretty printing\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Syntax.Visualization.ctx_dict-Tuple{Context, Theory, Any}","page":"Library Reference","title":"Gatlab.Syntax.Visualization.ctx_dict","text":"Get the strings required to print the a context t1 that extends t2. E.g. [[\"a\",\"b\",\"c\"]=>\"Ob\", [\"f\",\"g\"]=>[\"Hom(a,b)\"], ...]\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Trm, Int64}","page":"Library Reference","title":"Gatlab.Syntax.Visualization.show_inctx","text":"Show a debruijn level term in a theory + context i marks where the theory effectively ends (indices higher than this  refer to the context).\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Typ, Int64}","page":"Library Reference","title":"Gatlab.Syntax.Visualization.show_inctx","text":"Show a debruijn level type in a theory + context\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Logic.EGraphs.context-Tuple{EGraph, ETrm}","page":"Library Reference","title":"Gatlab.Logic.EGraphs.context","text":"This computes the inferred context for an etrm.\n\nFor example, if f is an id with etyp Hom(x,y) and g is an id with etyp Hom(y,z), then context(eg, :(g ∘ f)) computes the context [x,y,z,f,g].\n\nThe tricky thing comes from term formers like\n\nweaken(x)::Term(n) ⊣ [n::Nat, x::Term(S(n))]\n\nWe get the ETyp for x from the e-graph, and then we have to ematch its argument with S(n) to figure out what n is... The problem is that in general S will not be injective, so this is ambiguous!\n\nWhat we are going to do for now is say that types in the context of a term former can't be nested. I.e., we only allow types of the form Term(n), not Term(S(n)).\n\nFortunately, I don't think we care about any theories with this kind of context former.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Models.ModelInterface.Model","page":"Library Reference","title":"Gatlab.Models.ModelInterface.Model","text":"A Julia value with type Model{T, Tuple{Ts...}} represents a model of the theory T that has the types Ts... assigned to the type constructors in T.\n\nNote that we do not expect that structs subtyping Model will necessarily be singletons. In general, they may contain runtime data which is used in the implementations of the various methods. For instance, this would be the case for a slice category: the Model corresponding to a slice category would have runtime data of the object that we are slicing over.\n\nAn instance of Model{T, Tuple{Ts...}} should have overloads for\n\ncheckvalidity\nap\n\nas described in the docstrings for each of these methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#Gatlab.Models.ModelInterface.ap","page":"Library Reference","title":"Gatlab.Models.ModelInterface.ap","text":"Meant to be overloaded as\n\nap(m::Model{T}, ::TrmTag{i}, args...; context_args...)\n\nwhere:\n\ni is the level of a term constructor in T\nargs consists of, for each argument to the term constructor i, a valid value\n\nof the relevant type\n\ncontext_args consists of keyword arguments for each of the elements of\n\nthe context that are not mentioned in args. Sometimes these are needed for implementation, sometimes they are not, so it is possible to call ap without instantiating all of these and hoping for the best.\n\nReturns the result of applying the term constructor to the arguments, according to the model m. For instance, this is used to compose morphisms, or to get the identity morphism at an object.\n\nNote that we assume in ap that the arguments have already been checked, using checkvalidity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Gatlab.Models.ModelInterface.checkvalidity","page":"Library Reference","title":"Gatlab.Models.ModelInterface.checkvalidity","text":"Meant to be overloaded as\n\ncheckvalidity(m::Model{T}, ::TypTag{i}, args..., x) where {T <: AbstractTheory} = ...\n\nwhere:\n\ni is the level of a type constructor in T\nargs are the pre-checked type arguments to the type constructor\nx is the value to be checked\n\nReturns a boolean which is true if x is a valid element of the type i with type arguments args... according to Model and false otherwise.\n\nA basic implementation of checkvalidity might simply use dispatching on the type to return true. But in general, it might be necessary to verify runtime data, for instance checking that something is sorted or something is injective.\n\n\n\n\n\n","category":"function"},{"location":"api/#Gatlab.Models.ModelInterface.checkvalidity-Tuple{Model, TypTag, Vararg{Any}}","page":"Library Reference","title":"Gatlab.Models.ModelInterface.checkvalidity","text":"If not otherwise specified, we assume that a given value is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Gatlab.Dsl","page":"Library Reference","title":"Gatlab.Dsl","text":"A module for various features of Gatlab packaged as domain specific languages\n\n\n\n\n\n","category":"module"},{"location":"concepts/models/#Model-families","page":"Model families","title":"Model families","text":"","category":"section"},{"location":"concepts/models/","page":"Model families","title":"Model families","text":"The semantics part of Gatlab is the model family infrastructure.","category":"page"},{"location":"concepts/models/","page":"Model families","title":"Model families","text":"Given a theory, one can declare a model family for that theory. This consists of the following.","category":"page"},{"location":"concepts/models/","page":"Model families","title":"Model families","text":"A struct T. Each value of the struct is a model of the theory. The struct subtypes Model{Th, Tuple{Ts...}}. Th is the theory that the struct is a model family for, and Ts specifies types for each of the type constructors in Theory.\nFor each type constructor i in Theory, an overload of checkvalidity of the form\ncheckvalidity(m::T, ::TypCon{i}, args..., val) = ...\nThis checks that val is a valid instance of i applied to args..., assuming that args... have been previously checked to be valid.\nThis can then be applied using, for instance\ncheckvalidity(m, Category.Hom, x, y, f)\nusing the singleton structs defined in Theories\nFor each term constructor i in Theory, an overload of ap of the form\nap(m::T, ::TrmCon{i}, args...) = ...\nHere args... is to be interpreted as elements of the full context of the term constructor, not just the direct arguments of the term constructor itself. The reason for this is that the implementation of ap might need the data of, say, the domain and codomain of morphisms in order to compose them, and because we have an indexed form of dependent types, this information is not available from the morphism data itself.","category":"page"},{"location":"concepts/theories/#Theories","page":"Theories","title":"Theories","text":"","category":"section"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"A theory in Gatlab consists of two parts.","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"A Julia value of type Theory that describes the theory.\nA module named by the theory with various Julia types that give us handles","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"for metaprogramming.","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"These metaprogramming types include:","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"A singleton struct named Th and subtyping AbstractTheory that has an  overload of gettheory on it returning the Julia value from 1. This is used  to pass around the entire theory at the type level.\nA singleton struct for each type constructor and term constructor in the  theory. These are used in place of Lvl in types, so that backtraces are  more readable.","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"Example:","category":"page"},{"location":"concepts/theories/","page":"Theories","title":"Theories","text":"module Category\nusing Gatlab.Theories\n\nstruct Th <: AbstractTheory end\n\nTheories.gettheory(::Th) = ...\n\nstruct Ob <: TypCon{1} end\nstruct Hom <: TypCon{2} end\n\nstruct compose <: TrmCon{3} end\n...\nend","category":"page"},{"location":"stdlib/#Standard-Library","page":"Standard Library","title":"Standard Library","text":"","category":"section"},{"location":"stdlib/","page":"Standard Library","title":"Standard Library","text":"Modules = [Gatlab.Stdlib,\n  Gatlab.Stdlib.Categories,\n  Gatlab.Stdlib.Algebra,\n  ]","category":"page"},{"location":"stdlib/#Gatlab.Stdlib.StdTheories.Categories.TypedHom","page":"Standard Library","title":"Gatlab.Stdlib.StdTheories.Categories.TypedHom","text":"Any implementor of TypedHom{Ob, Hom} should have precisely the fields\n\ndom::Ob\ncodom::Ob\nmorphism::Hom\n\nThe reason this is not a struct is that we want to be able to control the name of the type.\n\n\n\n\n\n","category":"type"},{"location":"#Gatlab.jl","page":"Gatlab.jl","title":"Gatlab.jl","text":"","category":"section"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"CurrentModule = Gatlab","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"Gatlab.jl is a computer algebra system based on Generalized Algebraic Theories.","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"Roughly speaking, Gatlab consists of two parts. The first part is concerned with symbolic constructs. The prototypical symbolic construct is simply a term, i.e. a syntax tree. In Gatlab, every term is always relative to a context, in which the free variables in that term are typed. And the context and term themselves are relative to an underlying theory, which defines the allowable type and term constructors that can be used in contexts and terms, along with laws that allow one to rewrite terms into equivalent other terms.","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"We think about a term as a symbolic representation of a function from an assignment of values to the free variables to a value for the term. I.e., the term x^2 + y^2 represents the function mathbbR^2 to mathbbR given by (xy) mapsto x^2 + y^2. However, Gatlab also supports higher-level symbolic constructs. For instance, we can consider \"substitutions\" between contexts, which map free variables in one context to terms in another, as symbolic functions, and we can consider a collection of equations between terms in a context as a symbolic relation. We can use these building blocks to build symbolic dynamical systems and other things along these lines. Gatlab ensures that all of the manipulation of symbolic constructs is well-typed, so that you don't do something like accidently add a vector and a scalar.","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"The second part of Gatlab is concerned with computational semantics. The core of computational semantics is models of theories. A model tells you:","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"When a Julia value is a valid instance of a type in a theory\nHow to apply term constructors to Julia values","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"Given a model for a theory, a term in a context, and values for each of the free variables in that context, one can produce a new value by recursively applying the term constructors; this is known as interpreting the term. One can also compile the term by producing a Julia function that takes as its arguments values for the free variables in the context and then computes the value of the term. This can be faster than interpreting, because one only has to walk the syntax tree at runtime, not compile time. Analogous operations of interpretation and compilation can also be defined for higher level symbolic constructs. Moreover, Gatlab provides facilities for manipulation of models themselves. For instance, from a model of a ring, one can construct the model of a module over that ring, where the scalars are ring elements and the vectors are Vectors of ring elements.","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"Gatlab is the new backend for Catlab, and we are currently working to replace the old implementation of GATs with this new one.","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"There are many programs which have influenced the development of Gatlab, here we just list a few","category":"page"},{"location":"","page":"Gatlab.jl","title":"Gatlab.jl","text":"MMT\nMaude\nSymbolics.jl\nMetatheory.jl\nEgg\nStandard ML modules","category":"page"},{"location":"concepts/overview/#For-Catlab-users","page":"For Catlab users","title":"For Catlab users","text":"","category":"section"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Gatlab is a refactoring of the core GAT system in Catlab. There are three main differences between the Gatlab GAT system and the Catlab GAT system, in addition to a variety of new features enabled by these differences.","category":"page"},{"location":"concepts/overview/#.-Models-as-values","page":"For Catlab users","title":"1. Models as values","text":"","category":"section"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Instances (or models) of GATs in Catlab worked on a system analogous to Haskell type classes. That is, given a type and a GAT, that type could be involved in at most one instance of the GAT. However, there are many, many categories that have, for instance, integers as objects. The way to fix this was to make lots of \"newtype\" wrappers, like","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"struct FinSetInt\n  n::Int\nend","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"This is not ideal, but the larger problem is that this made it difficult to have models of a GAT that were parameterized by other models, because there was no way of referring to a particular model. So constructions like slice categories, dual categories, or cospan categories were not easy to do.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"In Gatlab, we instead do models of GATs in a more \"Standard ML\" style. That is, each model is a value that can be passed around dynamically. Then the implementations of the GAT term constructors are attached via multiple dispatch to that value. In simple cases, that value might be the unique instance of a zero-field struct, but more generally there could be more data inside the value, as is the case for slice categories. If the struct has fields, then we can think of it like a \"functor\" in ML parlance (which has little to do with the standard categorical use of the word functor); i.e. it is a parameterized model of the theory.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Sometimes we refer to this by \"categories as contexts\", because the category (i.e., the model of the theory of categories) serves as a context for disambiguating which method to use, and this is a pun off of the famous category theory book \"Categories in Context\" by Emily Riehl.","category":"page"},{"location":"concepts/overview/#.-E-Graphs","page":"For Catlab users","title":"2. E-Graphs","text":"","category":"section"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"An e-graph is a data structure used to store congruence relations on a collections of terms. A congruence relation is an equivalence relation with the property that if x_i sim x_i, then f(x_1ldotsx_n) sim f(x_1ldotsx_n) for any term constructor f. E-graphs are used for a variety of purposes, including:","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"finding simple representations of terms\ndeciding whether two terms are equal","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"The syntax systems we use for GATs in Gatlab are built from the ground-up to be compatible with a purpose-built e-graph implementation. This allows us to make use of the axioms in a GAT to rewrite terms and perform equational reasoning.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Additionally, it allows us to perform a weak form of typechecking. Typechecking in general for a GAT requires deciding the equality of arbitrary terms, which is undecidable. However, we can typecheck \"up to\" the collection of equivalences that we have recorded in an e-graph. Any well-typed term can be typechecked using this procedure by first placing the necessary equalities in the e-graph and then running the type-checking algorithm. Moreover, whenever this algorithm finds a positive result, one can be sure that the term does in fact typecheck. This is analogous to the termination-checking in proof assistants; we circumvent undecidability by putting the burden on the user to give us some additional data to show that their program is valid. And in many circumstances, very little additional data is required. For instance, in the bare theory of categories, there are no term constructors that produce objects. So checking whether two objects are equal in a presentation of a category is a simple problem of computing an equivalence relation (instead of a congruence relation). Thus, typechecking is very easy in this circumstance.","category":"page"},{"location":"concepts/overview/#.-Indexed-dependent-types-in-models","page":"For Catlab users","title":"3. Indexed dependent types in models","text":"","category":"section"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"A morphism between the finite sets 1ldotsn and 1ldotsm is simply a length-n vector whose entries are in 1ldotsm. However, in Catlab we cannot make a model of the theory of categories which has Vector{Int} as its type for morphisms. This is because we require an implementation of dom and codom to have a model, and it is not possible to infer the size of the codomain from a Vector{Int}.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Mathematically, this can be interpreted as a requirement that models of GATs interpret the dependent types as fibered. I.e. the dependent type Hom(a::Ob,b::Ob) gets interpreted as a Julia type Hom with functions dom, codom from Hom to Ob.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"The practical downside to this is that if you want to store several morphisms that have the same domain/codomain, you have to redundantly store the domain and codomain. So although a C-set consists of a collection of objects and morphisms in FinSet, we do not actually define it in this way in Catlab, because we don't want to redundantly store the objects in each morphism.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"In Gatlab, we fix this in the following way. When you declares a model in Gatlab, you associate types to it that correspond to the \"bare\" data. I.e., we would just associate Vector{Int} to Hom in an implementation of FinSet. Then various methods expect you to pass in the domain and codomain of a morphism in addition to the data of the morphism, rather than assuming that you can infer the domain and codomain from the data.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Mathematically, we interpret this by saying that we interpret the dependent types as indexed. That is, we assign a set to each pair of objects, and those sets can intersect. I.e., Hom(a,b) could intersect non-trivially Hom(c,d). So whenever we handle a morphism, we need external data that tells us what the domain and codomain is.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Notice that from such an implementation, we can automatically derive a wrapper type which contains domain, codomain, and data. But we can't go the other way; we can't automatically \"pick out\" what is data and what is just recording domain/codomain from the fibered implementation.","category":"page"},{"location":"concepts/overview/","page":"For Catlab users","title":"For Catlab users","text":"Although mathematically, fibered and indexed dependent types are equivalent, they have different implementations, and we hope that the indexed point of view will end up being more natural for our purposes.","category":"page"}]
}
