<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GATlab.jl</title><meta name="title" content="Library Reference · GATlab.jl"/><meta property="og:title" content="Library Reference · GATlab.jl"/><meta property="twitter:title" content="Library Reference · GATlab.jl"/><meta name="description" content="Documentation for GATlab.jl."/><meta property="og:description" content="Documentation for GATlab.jl."/><meta property="twitter:description" content="Documentation for GATlab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GATlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/overview/">For Catlab users</a></li><li><a class="tocitem" href="../concepts/theories/">Theories</a></li><li><a class="tocitem" href="../concepts/models/">Model families</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Binding" href="#GATlab.Syntax.Scopes.Binding"><code>GATlab.Syntax.Scopes.Binding</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Binding{T}</code></p><p>A binding associates some <code>T</code>-typed value to a name.</p><p><code>name</code> is an optional distinguished name <code>value</code> is the element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Context" href="#GATlab.Syntax.Scopes.Context"><code>GATlab.Syntax.Scopes.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Context</code> is anything which contains an ordered list of scopes.</p><p>Scopes within a context are referred to by <em>level</em>, which is their index within this list.</p><p><code>Context</code>s should overload:</p><ul><li><code>getscope(c::Context, level::Int) -&gt; Scope</code></li><li><code>nscopes(c::Context) -&gt; Int</code></li><li><code>hastag(c::Context, tag::ScopeTag) -&gt; Bool</code></li><li><code>hasname(c::Context, name::Symbol) -&gt; Bool</code></li><li><code>getlevel(c::Context, tag::ScopeTag) -&gt; Int</code></li><li><code>getlevel(c::Context, name::Symbol) -&gt; Int</code></li><li><code>alltags(c::Context) -&gt; Set{ScopeTag}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScope" href="#GATlab.Syntax.Scopes.HasScope"><code>GATlab.Syntax.Scopes.HasScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type for wrappers around a single scope.</p><p>Must overload</p><p><code>getscope(hs::HasScope) -&gt; Scope</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScopeList" href="#GATlab.Syntax.Scopes.HasScopeList"><code>GATlab.Syntax.Scopes.HasScopeList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A type for things which contain a scope list.</p><p>Notably, GATs contain a scope list.</p><p>Must implement:</p><p><code>getscopelist(hsl::HasScopeList) -&gt; ScopeList</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L671-L679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Ident" href="#GATlab.Syntax.Scopes.Ident"><code>GATlab.Syntax.Scopes.Ident</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Ident</code></p><p>An identifier.</p><p><code>tag</code> refers to the scope that this Ident is bound in <code>lid</code> indexes the scope that Ident is bound in <code>name</code> is an optional field for the sake of printing. A variable in a scope might be associated with several names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L112-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.LID" href="#GATlab.Syntax.Scopes.LID"><code>GATlab.Syntax.Scopes.LID</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A LID (Local ID) indexes a given scope.</p><p>Currently, scopes assign LIDs sequentially – this is not a stable guarantee however, and in theory scopes could have &quot;sparse&quot; LIDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Scope" href="#GATlab.Syntax.Scopes.Scope"><code>GATlab.Syntax.Scopes.Scope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Scope{T}</code></p><p>In GATlab, we handle shadowing with a notion of <em>scope</em>. Names shadow between scopes. Anything which binds variables introduces a scope, for instance a <code>@theory</code> declaration or a context. For example, here is a scope with 3 elements:</p><pre><code class="nohighlight hljs">x = 3
y = &quot;hello&quot;
z = x </code></pre><p>Here z is introduced as an alias for x. It is illegal to shadow within a scope. Overloading is not explicitly treated but can be managed by having values which  refer to identifiers earlier / the present scope. See GATs.jl, for example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L325-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTag" href="#GATlab.Syntax.Scopes.ScopeTag"><code>GATlab.Syntax.Scopes.ScopeTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The tag that makes reference to a specific scope possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTagError" href="#GATlab.Syntax.Scopes.ScopeTagError"><code>GATlab.Syntax.Scopes.ScopeTagError</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ScopeTagError</code></p><p>An error to throw when an identifier has an unexpected scope tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopedBinding" href="#GATlab.Syntax.Scopes.ScopedBinding"><code>GATlab.Syntax.Scopes.ScopedBinding</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for printing out bindings with colored keys</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.getidents-Tuple{HasScope}" href="#GATlab.Syntax.Scopes.getidents-Tuple{HasScope}"><code>GATlab.Syntax.Scopes.getidents</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This collects all the idents in a scope</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.getlid-Tuple{HasScope, Symbol}" href="#GATlab.Syntax.Scopes.getlid-Tuple{HasScope, Symbol}"><code>GATlab.Syntax.Scopes.getlid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the level of a binding given the name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L454-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.hasident-Tuple{Context}" href="#GATlab.Syntax.Scopes.hasident-Tuple{Context}"><code>GATlab.Syntax.Scopes.hasident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hasident</code> checks whether an identifier with specified data exists, by attempting to create it and returning whether or not that attempt failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L634-L637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ident-Tuple{Context}" href="#GATlab.Syntax.Scopes.ident-Tuple{Context}"><code>GATlab.Syntax.Scopes.ident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ident</code> creates an <code>Ident</code> from a context and some partial data supplied as keywords.</p><p>Keywords arguments:</p><ul><li><code>tag::Union{ScopeTag, Nothing}</code>. The tag of the scope that the <code>Ident</code> is in.</li><li><code>name::Union{Symbol, Nothing}</code>. The name of the identifier.</li><li><code>lid::Union{LID, Nothing}</code>. The lid of the identifier within its scope.</li><li><code>level::Union{Int, Nothing}</code>. The level of the scope within the context.</li><li><code>strict::Bool</code>. If <code>strict</code> is true, throw an error if not found, else return nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L592-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.idents-Tuple{Context}" href="#GATlab.Syntax.Scopes.idents-Tuple{Context}"><code>GATlab.Syntax.Scopes.idents</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a broadcasted version of <code>ident</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L647-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}" href="#GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}"><code>GATlab.Syntax.Scopes.rename</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rename(tag::ScopeTag, replacements::Dict{Symbol, Symbol}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, and change any name <code>n</code> in scope <code>tag</code> to <code>get(replacements, n, n)</code>. Overload this function on structs that have names in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}" href="#GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}"><code>GATlab.Syntax.Scopes.retag</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>retag(replacements::Dict{ScopeTag, ScopeTag}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, swapping any instance of a ScopeTag <code>t</code> with <code>get(replacements, t, t)</code>. Overload this function on structs that have ScopeTags within them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.unsafe_pushbinding!-Union{Tuple{T}, Tuple{Scope{T}, Binding{T}}} where T" href="#GATlab.Syntax.Scopes.unsafe_pushbinding!-Union{Tuple{T}, Tuple{Scope{T}, Binding{T}}} where T"><code>GATlab.Syntax.Scopes.unsafe_pushbinding!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a new binding to the end of Scope <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/Scopes.jl#L422-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AbstractConstant" href="#GATlab.Syntax.GATs.AbstractConstant"><code>GATlab.Syntax.GATs.AbstractConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We need this to resolve a mutual reference loop; the only subtype is Constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAccessor" href="#GATlab.Syntax.GATs.AlgAccessor"><code>GATlab.Syntax.GATs.AlgAccessor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgAccessor</code></p><p>The arguments to a term constructor serve a dual function as both arguments and also methods to extract the value of those arguments.</p><p>I.e., declaring <code>Hom(dom::Ob, codom::Ob)::TYPE</code> implicitly overloads a previous declaration for <code>dom</code> and <code>codom</code>, or creates declarations if none previously exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L70-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAxiom" href="#GATlab.Syntax.GATs.AlgAxiom"><code>GATlab.Syntax.GATs.AlgAxiom</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgAxiom</code></p><p>A declaration of an axiom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgDeclaration" href="#GATlab.Syntax.GATs.AlgDeclaration"><code>GATlab.Syntax.GATs.AlgDeclaration</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgDeclaration</code></p><p>A declaration of a constructor; constructor methods in the form of <code>AlgTermConstructors</code> or the accessors for <code>AlgTypeConstructors</code> follow later in the theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSort" href="#GATlab.Syntax.GATs.AlgSort"><code>GATlab.Syntax.GATs.AlgSort</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSort</code></p><p>A <em>sort</em>, which is essentially a type constructor without arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSorts" href="#GATlab.Syntax.GATs.AlgSorts"><code>GATlab.Syntax.GATs.AlgSorts</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSorts</code></p><p>A description of the argument sorts for a term constructor, used to disambiguate multiple term constructors of the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTerm" href="#GATlab.Syntax.GATs.AlgTerm"><code>GATlab.Syntax.GATs.AlgTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTerm</code></p><p>One syntax tree to rule all the terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTermConstructor" href="#GATlab.Syntax.GATs.AlgTermConstructor"><code>GATlab.Syntax.GATs.AlgTermConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTermConstructor</code></p><p>A declaration of a term constructor as a method of an <code>AlgFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgType" href="#GATlab.Syntax.GATs.AlgType"><code>GATlab.Syntax.GATs.AlgType</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgType</code></p><p>One syntax tree to rule all the types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTypeConstructor" href="#GATlab.Syntax.GATs.AlgTypeConstructor"><code>GATlab.Syntax.GATs.AlgTypeConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTypeConstructor</code></p><p>A declaration of a type constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Constant" href="#GATlab.Syntax.GATs.Constant"><code>GATlab.Syntax.GATs.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Constant</code></p><p>A Julia value in an algebraic context. Type checked elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Eq" href="#GATlab.Syntax.GATs.Eq"><code>GATlab.Syntax.GATs.Eq</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Eq</code></p><p>The type of equality judgments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GAT" href="#GATlab.Syntax.GATs.GAT"><code>GATlab.Syntax.GATs.GAT</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GAT</code></p><p>A generalized algebraic theory. Essentially, just consists of a name and a list of <code>GATSegment</code>s, but there is also some caching to make access faster. Specifically, there is a dictionary to map ScopeTag to position in the list of segments, and there are lists of all of the identifiers for term constructors, type constructors, and axioms so that they can be iterated through faster.</p><p>GATs allow overloading but not shadowing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/gat.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GATContext" href="#GATlab.Syntax.GATs.GATContext"><code>GATlab.Syntax.GATs.GATContext</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GATContext</code></p><p>A context consisting of two parts: a GAT and a TypeCtx</p><p>Certain types (like AlgTerm) can only be parsed in a GATContext, because they require access to the method resolving in the GAT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/gat.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GATSegment" href="#GATlab.Syntax.GATs.GATSegment"><code>GATlab.Syntax.GATs.GATSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GATSegment</code></p><p>A piece of a GAT, consisting of a scope that binds judgments to names, possibly disambiguated by argument sorts.</p><p>This is a struct rather than just a type alias so that we can customize the show method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/gat.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.InCtx-Union{Tuple{AlgType}, Tuple{GAT, Ident}} where AlgType" href="#GATlab.Syntax.GATs.InCtx-Union{Tuple{AlgType}, Tuple{GAT, Ident}} where AlgType"><code>GATlab.Syntax.GATs.InCtx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the canonical type + ctx associated with a type constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L152-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.InCtx-Union{Tuple{T}, Tuple{GAT, Ident}} where T&lt;:AlgAST" href="#GATlab.Syntax.GATs.InCtx-Union{Tuple{T}, Tuple{GAT, Ident}} where T&lt;:AlgAST"><code>GATlab.Syntax.GATs.InCtx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the canonical term + ctx associated with a method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Judgment" href="#GATlab.Syntax.GATs.Judgment"><code>GATlab.Syntax.GATs.Judgment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A GAT is conceptually a bunch of <code>Judgment</code>s strung together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.MethodApp" href="#GATlab.Syntax.GATs.MethodApp"><code>GATlab.Syntax.GATs.MethodApp</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>MethodApp</code></p><p>An application of a method of a constructor to arguments. We need a type parameter <code>T</code> because <code>AlgTerm</code> hasn&#39;t been defined yet, but the only type used for <code>T</code> will in fact be <code>AlgTerm</code>.</p><p><code>method</code> either points to an <code>AlgTermConstructor</code>, an <code>AlgTypeConstructor</code> or an <code>AlgAccessor</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.MethodResolver" href="#GATlab.Syntax.GATs.MethodResolver"><code>GATlab.Syntax.GATs.MethodResolver</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>MethodResolver</code></p><p>Right now, this just maps a sort signature to the resolved method.</p><p>When we eventually support varargs, this will have to do something slightly fancier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/gat.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.TypeScope" href="#GATlab.Syntax.GATs.TypeScope"><code>GATlab.Syntax.GATs.TypeScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TypeScope</code></p><p>A scope where variables are assigned to <code>AlgType</code>s. We use a wrapper here so that it pretty prints as <code>[a::B]</code> instead of <code>{a =&gt; AlgType(B)}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/judgments.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, T}} where T&lt;:Union{AlgTerm, AlgType}" href="#Base.show-Union{Tuple{T}, Tuple{IO, T}} where T&lt;:Union{AlgTerm, AlgType}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Common methods for AlgType and AlgTerm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/ast.jl#L130-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{GAT, Any, Any}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{GAT, Any, Any}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coerce GATs to GAT contexts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/exprinterop.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr-Tuple{GAT, GATSegment}" href="#GATlab.Syntax.ExprInterop.toexpr-Tuple{GAT, GATSegment}"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This only works when <code>seg</code> is a segment of <code>theory</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/exprinterop.jl#L346-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}" href="#GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get equations for a term or type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{GATContext, AbstractVector{Ident}}" href="#GATlab.Syntax.GATs.equations-Tuple{GATContext, AbstractVector{Ident}}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implicit equations defined by a context.</p><p>This function allows a generalized algebraic theory (GAT) to be expressed as an essentially algebraic theory, i.e., as partial functions whose domains are defined by equations.</p><p>References:</p><ul><li>(Cartmell, 1986, Sec 6: &quot;Essentially algebraic theories and categories with  finite limits&quot;)</li><li>(Freyd, 1972, &quot;Aspects of topoi&quot;)</li></ul><p>This function gives expressions for computing the elements of <code>c.context</code>   which can be inferred from applying accessor functions to elements of <code>args</code>.</p><p>Example:</p><blockquote><p>equations({f::Hom(a,b), g::Hom(b,c)}, {a::Ob, b::Ob, c::Ob}, ThCategory)</p></blockquote><p>ways<em>of</em>computing = Dict(a =&gt; [dom(f)], b =&gt; [codom(f), dom(g)], c =&gt; [codom(g)],                          f =&gt; [f], g =&gt; [g])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.normalize_judgment-Tuple{Any}" href="#GATlab.Syntax.GATs.normalize_judgment-Tuple{Any}"><code>GATlab.Syntax.GATs.normalize_judgment</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is necessary because the intuitive precedence rules for the symbols that we use do not match the Julia precedence rules. In theory, this could be written with some algorithm that recalculates precedence, but I am too lazy to write that, so instead I just special case everything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/exprinterop.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.parse_scope!-Tuple{Function, Scope, AbstractVector}" href="#GATlab.Syntax.GATs.parse_scope!-Tuple{Function, Scope, AbstractVector}"><code>GATlab.Syntax.GATs.parse_scope!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>f(pushbinding!, expr)</code> should inspect <code>expr</code> and call <code>pushbinding!</code> 0 or more times with two arguments: the name and value of a new binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/exprinterop.jl#L175-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgTerm)</code></p><p>Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgType)</code></p><p>Throw an error if a the head of an AlgType (which refers to a type constructor) has arguments of the wrong sort.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.substitute_term-Union{Tuple{T}, Tuple{T, Dict{Ident, AlgTerm}}} where T&lt;:AlgAST" href="#GATlab.Syntax.GATs.substitute_term-Union{Tuple{T}, Tuple{T, Dict{Ident, AlgTerm}}} where T&lt;:AlgAST"><code>GATlab.Syntax.GATs.substitute_term</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace idents with AlgTerms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/gats/algorithms.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{GATContext, Any, Type{GATContext}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{GATContext, Any, Type{GATContext}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse, e.g.:</p><pre><code class="nohighlight hljs">(a,b,c)::Ob
f::Hom(a, b)
g::Hom(b, c)
h::Hom(a, c)
h′::Hom(a, c)
compose(f, g) == h == h′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/GATContexts.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr" href="#GATlab.Syntax.ExprInterop.fromexpr"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fromexpr(c::Context, e::Any, T::Type) -&gt; Union{T,Nothing}</code></p><p>Converts a Julia Expr into type T, in a certain scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/ExprInterop.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr" href="#GATlab.Syntax.ExprInterop.toexpr"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>toexpr(c::Context, t) -&gt; Any</code></p><p>Converts GATlab syntax into an Expr that can be read in via <code>fromexpr</code> to get the same thing. Crucially, the output of this will depend on the order of the scopes in <code>c</code>, and if read back in with a different <code>c</code> may end up with different results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/ExprInterop.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP" href="#GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP"><code>GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>When we declare a new theory, we add the scope tag of its new segment to this dictionary pointing to the module corresponding to the new theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/TheoryInterface.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.fqmn-Tuple{Module}" href="#GATlab.Syntax.TheoryInterface.fqmn-Tuple{Module}"><code>GATlab.Syntax.TheoryInterface.fqmn</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fully Qualified Module Name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/syntax/TheoryInterface.jl#L50-L52">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.ImplementationNotes" href="#GATlab.Models.ModelInterface.ImplementationNotes"><code>GATlab.Models.ModelInterface.ImplementationNotes</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ImplementationNotes</code></p><p>Information about how a model implements a <code>GATSegment</code>. Right now, just the docstring attached to the <code>@instance</code> macro, but could contain more info in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag" href="#GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag"><code>GATlab.Models.ModelInterface.implements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>implements(m::Model, tag::ScopeTag) -&gt; Union{ImplementationNotes, Nothing}</code></p><p>If <code>m</code> implements the GATSegment referred to by <code>tag</code>, then return the corresponding implementation notes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr, GAT}" href="#GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr, GAT}"><code>GATlab.Models.ModelInterface.parse_instance_body</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses the raw julia expression into JuliaFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}" href="#GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}"><code>GATlab.Models.ModelInterface.qualify_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add <code>WithModel</code> param first, if this is not an old instance (it shouldn&#39;t have it already) Qualify method name to be in theory module Add <code>context</code> kwargs if not already present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.to_call_impl-Tuple{AlgTerm, Any, Module}" href="#GATlab.Models.ModelInterface.to_call_impl-Tuple{AlgTerm, Any, Module}"><code>GATlab.Models.ModelInterface.to_call_impl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile an AlgTerm into a Julia call Expr where termcons (e.g. <code>f</code>) are interpreted as <code>mod.f[model.model](...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L705-L708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}" href="#GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}"><code>GATlab.Models.ModelInterface.typecheck_instance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Throw error if missing a term constructor. Provides default instances for type constructors and type arguments, which return true or error, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L352-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}" href="#GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}"><code>GATlab.Models.ModelInterface.@instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Usage:</p><pre><code class="language-julia hljs">struct TypedFinSetC &lt;: Model{Tuple{Vector{Int}, Vector{Int}}}
  ntypes::Int
end

@instance ThCategory{Vector{Int}, Vector{Int}} [model::TypedFinSetC] begin
  Ob(v::Vector{Int}) = all(1 &lt;= j &lt;= model.ntypes for j in v)
  Hom(f::Vector{Int}, v::Vector{Int}, w::Vector{Int}) =
     length(f) == length(v) &amp;&amp; all(1 &lt;= y &lt;= length(w) for y in f)

  id(v::Vector{Int}) = collect(eachindex(v))
  compose(f::Vector{Int}, g::Vector{Int}) = g[f]

  dom(f::Vector{Int}; context) = context.dom
  codom(f::Vector{Int}; context) = context.codom
end

struct SliceCat{Ob, Hom, C &lt;: Model{Tuple{Ob, Hom}}} &lt;: Model{Tuple{Tuple{Ob, Hom}, Hom}}
  c::C
end

@instance ThCategory{Tuple{Ob, Hom}, Hom} [model::SliceCat{Ob, Hom, C}] where {Ob, Hom, C&lt;:Model{Tuple{Ob, Hom}}} begin
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L104-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.@migrate-Tuple{Any}" href="#GATlab.Models.ModelInterface.@migrate-Tuple{Any}"><code>GATlab.Models.ModelInterface.@migrate</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Given a Theory Morphism T-&gt;U and a type Mᵤ (whose values are models of U), obtain a type Mₜ which has one parameter (of type Mᵤ) and is a model of T.</p><p>E.g. given NatIsMonoid: ThMonoid-&gt;ThNatPlus and IntPlus &lt;: Model{Tuple{Int}} and IntPlus implements ThNatPlus:</p><pre><code class="nohighlight hljs">@migrate IntPlusMonoid = NatIsMonoid(IntPlus){Int}</code></pre><p>Yields:</p><pre><code class="nohighlight hljs">struct IntPlusMonoid &lt;: Model{Tuple{Int}}
  model::IntPlus
end

@instance ThMonoid{Int} [model::IntPlusMonoid] begin ... end</code></pre><p>Future work: There is some subtlety in how accessor functions should be handled. TODO: The new instance methods do not yet handle the <code>context</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/ModelInterface.jl#L580-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.GATExpr" href="#GATlab.Models.SymbolicModels.GATExpr"><code>GATlab.Models.SymbolicModels.GATExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base type for expressions in the syntax of a GAT. This is an alternative to <code>AlgTerm</code> used for backwards compatibility with Catlab.</p><p>We define Julia types for each <em>type constructor</em> in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia&#39;s type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)</p><p>The concrete types are structurally similar to the core type <code>Expr</code> in Julia. However, the <em>term constructor</em> is represented as a type parameter, rather than as a <code>head</code> field. This makes dispatch using Julia&#39;s type system more convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.nameof-Tuple{GATExpr{:generator}}" href="#Base.nameof-Tuple{GATExpr{:generator}}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get name of GAT generator expression as a <code>Symbol</code>.</p><p>If the generator has no name, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.constructor_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Name of constructor that created expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L500-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}" href="#GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor from GAT expression to GAT instance.</p><p>Strictly speaking, we should call these &quot;structure-preserving functors&quot; or, better, &quot;model homomorphisms of GATs&quot;. But this is a category theory library, so we&#39;ll go with the simpler &quot;functor&quot;.</p><p>A functor is completely determined by its action on the generators. There are several ways to specify this mapping:</p><ol><li><p>Specify a Julia instance type for each GAT type, using the required <code>types</code> tuple. For this to work, the generator constructors must be defined for the instance types.</p></li><li><p>Explicitly map each generator term to an instance value, using the <code>generators</code> dictionary.</p></li><li><p>For each GAT type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the <code>terms</code> dictionary.</p></li></ol><p>The <code>terms</code> dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.</p><p>FIXME</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L521-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.generator_like-Tuple{GATExpr, Any}" href="#GATlab.Models.SymbolicModels.generator_like-Tuple{GATExpr, Any}"><code>GATlab.Models.SymbolicModels.generator_like</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create generator of the same type as the given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L511-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}" href="#GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}"><code>GATlab.Models.SymbolicModels.parse_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize expression from JSON-able S-expression.</p><p>If <code>symbols</code> is true (the default), strings are converted to symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L594-L598">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_latex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using LaTeX math.</p><p>Does <em>not</em> include <code>$</code> or <code>\[begin|end]{equation}</code> delimiters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L675-L679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the syntax expression as an S-expression.</p><p>Cf. the standard library function <code>Meta.show_sexpr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_unicode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using Unicode symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L650-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}" href="#GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}"><code>GATlab.Models.SymbolicModels.symbolic_instance_methods</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Julia function for every type constructor, accessor, and term constructor. Term constructors can be overwritten by <code>overrides</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L400-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.syntax_module</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get syntax module of given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L505-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.to_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize expression as JSON-able S-expression.</p><p>The format is an S-expression encoded as JSON, e.g., &quot;compose(f,g)&quot; is represented as [&quot;compose&quot;, f, g].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L578-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}" href="#GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}"><code>GATlab.Models.SymbolicModels.@symbolic_model</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@symbolic_model generates the free model of a theory, generated by symbols.</p><p>This is backwards compatible with the @syntax macro in Catlab.</p><p>One way of thinking about this is that for every type constructor, we add an additional term constructor that builds a &quot;symbolic&quot; element of that type from any Julia value. This term constructor is called &quot;generator&quot;.</p><p>An invocation of <code>@symbolic_model</code> creates the following.</p><ol><li>A module with a struct for each type constructor, which has a single type</li></ol><p>parameter <code>T</code> and two fields, <code>args</code> and <code>type_args</code>. Instances of this struct are thought of as elements of the type given by the type constructor applied to <code>type_args</code>. The type parameter refers to the term constructor that was used to generate the element, including the special term constructor <code>:generator</code>, which has as its single argument an <code>Any</code>.</p><p>For instance, in the theory of categories, we might have the following elements.</p><pre><code class="nohighlight hljs">using .FreeCategory
x = Ob{:generator}([:x], [])
y = Ob{:generator}([:y], [])
f = Hom{:generator}([:f], [x, y])
g = Hom{:generator}([:g], [y, x])
h = Hom{:compose}([f, g], [x, x])</code></pre><ol><li>Methods inside the module (not exported) for all of the term constructors and</li></ol><p>field accessors (i.e. stuff like <code>compose, id, dom, codom</code>), which construct terms.</p><ol><li>A default instance (i.e., without a model parameter) of the theory using the</li></ol><p>types in this generated model. Methods in this instance can be overridden by the body of <code>@symbolic_model</code> to perform rewriting for the sake of normalization, for instance flattening associative and unital operations.</p><ol><li>Coercion methods of the type constructors that allow one to introduce generators.</li></ol><pre><code class="nohighlight hljs">x = ThCategory.Ob(FreeCategory.Ob, :x)
y = ThCategory.Ob(FreeCategory.Ob, :y)
f = ThCategory.Hom(:f, x, y)</code></pre><p>Note that in both the instance and in these coercion methods, we must give the expected type as the first argument when it cannot be infered by the other arguments. For instance, instead of</p><pre><code class="nohighlight hljs">munit() = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">munit(::Type{FreeSMC.Ob}) = ...</code></pre><p>and likewise instead of</p><pre><code class="nohighlight hljs">ThCategory.Ob(x::Any) = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">ThCategory.Ob(::Type{FreeCategory.Ob}, x::Any) = ...</code></pre><p>Example:</p><pre><code class="language-julia hljs">@symbolic_model FreeCategory{ObExr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate_unit(new(f,g; strict=true), id)
end</code></pre><p>This generates:</p><pre><code class="language-julia hljs">module FreeCategory
export Ob, Hom
using ..__module__

const THEORY_MODULE = ThCategory

struct Ob{T} &lt;: __module__.ObExpr{T} # T is :generator or a Symbol
  args::Vector
  type_args::Vector{GATExpr}
end

struct Hom{T} &lt;: __module__.HomExpr{T}
  args::Vector
  type_args::Vector{GATExpr}
end

dom(x::Hom) = x.type_args[1]

codom(x::Hom) = x.type_args[2]

function compose(f::Hom, g::Hom; strict=true)
  if strict &amp;&amp; !(codom(f) == dom(g))
    throw(SyntaxDomainError(:compose, [f, g]))
  end
  Hom{:compose}([f, g], [dom(f), codom(g)])
end

function id(x::Ob)
  Ob{:id}([x], [x, x])
end
end

# default implementations 

function ThCategory.dom(x::FreeCategory.Hom)::FreeCategory.Ob
  FreeCategory.dom(x)
end

function ThCategory.Ob(::Type{FreeCategory.Ob}, __value__::Any)::FreeCategory.Ob
  FreeCategory.Ob{:generator}([__value__], [])
end

function ThCategory.id(A::FreeCategory.Ob)::FreeCategory.Hom
  FreeCategory.id(A)
end

function ThCategory.compose(f::FreeCategory.Hom, g::FreeCategory.Hom; strict=true)
  associate_unit(FreeCategory.compose(f, g; strict), id)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/models/SymbolicModels.jl#L93-L226">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils" href="#GATlab.Util.MetaUtils"><code>GATlab.Util.MetaUtils</code></a> — <span class="docstring-category">Module</span></header><section><div><p>General-purpose tools for metaprogramming in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.concat_expr-Tuple{Expr, Expr}" href="#GATlab.Util.MetaUtils.concat_expr-Tuple{Expr, Expr}"><code>GATlab.Util.MetaUtils.concat_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Concatenate two Julia expressions into a block expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L162-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}" href="#GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}"><code>GATlab.Util.MetaUtils.generate_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap Julia expression with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.generate_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate Julia expression for function definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia expression that is (possibly) annotated with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_function-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia function definition into standardized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.parse_function_sig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse signature of Julia function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occuring anywhere in a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L187-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occurring anywhere in a Julia function (except the name).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L173-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}" href="#GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}"><code>GATlab.Util.MetaUtils.strip_lines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove all LineNumberNodes from a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/5f1e177c149513e8dc8aa88dc0a51fd6c0ba38df/src/util/MetaUtils.jl#L198-L200">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/models/">« Model families</a><a class="docs-footer-nextpage" href="../stdlib/">Standard Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 12 October 2023 18:43">Thursday 12 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
