<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GATlab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GATlab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/overview/">For Catlab users</a></li><li><a class="tocitem" href="../concepts/theories/">Theories</a></li><li><a class="tocitem" href="../concepts/models/">Model families</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.Binding" href="#GATlab.Syntax.Scopes.Binding"><code>GATlab.Syntax.Scopes.Binding</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Binding{T, Sig}</code></p><p>A binding associates some <code>T</code>-typed value to a name and possibly some aliases, disambiguated by a signature in <code>Sig</code> in the case of overloading.</p><p><code>primary</code> is an optional distinguished element of aliases <code>value</code> is the element <code>sig</code> is a way of uniquely distinguishing this element from others with the same name  (for example, ⊗ : Ob x Ob -&gt; Ob and Hom x Hom -&gt; Hom)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L246-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.Context" href="#GATlab.Syntax.Scopes.Context"><code>GATlab.Syntax.Scopes.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Context</code> is anything which contains an ordered list of scopes.</p><p>Scopes within a context are referred to by <em>level</em>, which is their index within this list.</p><p><code>Context</code>s should overload:</p><ul><li><code>getscope(c::Context, level::Int) -&gt; Scope</code></li><li><code>nscopes(c::Context) -&gt; Int</code></li><li><code>hastag(c::Context, tag::ScopeTag) -&gt; Bool</code></li><li><code>hasname(c::Context, name::Symbol) -&gt; Bool</code></li><li><code>getlevel(c::Context, tag::ScopeTag) -&gt; Int</code></li><li><code>getlevel(c::Context, name::Symbol) -&gt; Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L322-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScope" href="#GATlab.Syntax.Scopes.HasScope"><code>GATlab.Syntax.Scopes.HasScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type for wrappers around a single scope.</p><p>Must overload</p><p><code>getscope(hs::HasScope) -&gt; Scope</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L358-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScopeList" href="#GATlab.Syntax.Scopes.HasScopeList"><code>GATlab.Syntax.Scopes.HasScopeList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A type for things which contain a scope list.</p><p>Notably, GATs contain a scope list.</p><p>Must implement:</p><p><code>getscopelist(hsl::HasScopeList) -&gt; ScopeList</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L769-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.Ident" href="#GATlab.Syntax.Scopes.Ident"><code>GATlab.Syntax.Scopes.Ident</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Ident</code></p><p>An identifier.</p><p><code>tag</code> refers to the scope that this Ident is bound in <code>lid</code> indexes the scope that Ident is bound in <code>name</code> is an optional field for the sake of printing. A variable in a scope might be associated with several names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.LID" href="#GATlab.Syntax.Scopes.LID"><code>GATlab.Syntax.Scopes.LID</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A LID (Local ID) indexes a given scope.</p><p>Currently, scopes assign LIDs sequentially – this is not a stable guarantee however, and in theory scopes could have &quot;sparse&quot; LIDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.Reference" href="#GATlab.Syntax.Scopes.Reference"><code>GATlab.Syntax.Scopes.Reference</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Reference</code></p><p>A path of identifiers. We optimize for the (frequent) case where there is only one identifier by making this a linked list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.Scope" href="#GATlab.Syntax.Scopes.Scope"><code>GATlab.Syntax.Scopes.Scope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Scope{T, Sig}</code></p><p>In GATlab, we handle overloading and shadowing with a notion of <em>scope</em>. Anything which binds variables introduces a scope, for instance a <code>@theory</code> declaration or a context. For example, a scope with 3 elements:</p><pre><code class="nohighlight hljs">x::Int = 3
y::String = &quot;hello&quot;
x::String = &quot;ex&quot;</code></pre><p>This is a valid scope even though there are name collisions, because the signature (in this case, a datatype) disambiguates. Of course, it may not be wise to disambiguate by type, because it is not always possible to infer expected type.  In general, one should pick something that can be inferred, and <code>Nothing</code> is always a reasonable choice, which disallows any name collisions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L393-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTag" href="#GATlab.Syntax.Scopes.ScopeTag"><code>GATlab.Syntax.Scopes.ScopeTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The tag that makes reference to a specific scope possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTagError" href="#GATlab.Syntax.Scopes.ScopeTagError"><code>GATlab.Syntax.Scopes.ScopeTagError</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ScopeTagError</code></p><p>An error to throw when an identifier has an unexpected scope tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{ScopeTag, ScopeTag}" href="#Base.:+-Tuple{ScopeTag, ScopeTag}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deterministically combine two scope tags into a third</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.equiv-Tuple{Scope, Scope}" href="#GATlab.Syntax.Scopes.equiv-Tuple{Scope, Scope}"><code>GATlab.Syntax.Scopes.equiv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compare two scopes, ignoring the difference in the top-level scope tag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.getlid-Union{Tuple{Sig}, Tuple{T}, Tuple{HasScope{T, Sig}, Symbol}} where {T, Sig}" href="#GATlab.Syntax.Scopes.getlid-Union{Tuple{Sig}, Tuple{T}, Tuple{HasScope{T, Sig}, Symbol}} where {T, Sig}"><code>GATlab.Syntax.Scopes.getlid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the level of a binding given the name and possibly the signature</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L534-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.hasident-Tuple{Context}" href="#GATlab.Syntax.Scopes.hasident-Tuple{Context}"><code>GATlab.Syntax.Scopes.hasident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hasident</code> checks whether an identifier with specified data exists, by attempting to create it and returning whether or not that attempt failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L732-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.ident-Tuple{Context}" href="#GATlab.Syntax.Scopes.ident-Tuple{Context}"><code>GATlab.Syntax.Scopes.ident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ident</code> creates an <code>Ident</code> from a context and some partial data supplied as keywords.</p><p>Keywords arguments:</p><ul><li><code>tag::Union{ScopeTag, Nothing}</code>. The tag of the scope that the <code>Ident</code> is in.</li><li><code>name::Union{Symbol, Nothing}</code>. The name of the identifier.</li><li><code>lid::Union{LID, Nothing}</code>. The lid of the identifier within its scope.</li><li><code>level::Union{Int, Nothing}</code>. The level of the scope within the context.</li><li><code>sig::Any</code>. The signature of the identifier, to disambiguate between multiple identifiers with the same name within the same scope.</li><li><code>strict::Bool</code>. If <code>strict</code> is true, throw an error if not found, else return nothing.</li><li><code>isunique::Bool</code>. If <code>isunique</code> is true, then don&#39;t use the signature to disambiguate, instead fail if their are multiple identifiers with the same name in a scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L684-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}" href="#GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}"><code>GATlab.Syntax.Scopes.rename</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rename(tag::ScopeTag, replacements::Dict{Symbol, Symbol}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, and change any name <code>n</code> in scope <code>tag</code> to <code>get(replacements, n, n)</code>. Overload this function on structs that have names in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}" href="#GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}"><code>GATlab.Syntax.Scopes.retag</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>retag(replacements::Dict{ScopeTag, ScopeTag}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, swapping any instance of a ScopeTag <code>t</code> with <code>get(replacements, t, t)</code>. Overload this function on structs that have ScopeTags within them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Scopes.unsafe_addalias!-Tuple{Scope, Symbol, Symbol}" href="#GATlab.Syntax.Scopes.unsafe_addalias!-Tuple{Scope, Symbol, Symbol}"><code>GATlab.Syntax.Scopes.unsafe_addalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>unsafe_addalias!</code> should only be used when <code>unsafe_pushbinding!</code> won&#39;t be called again, because new bindings won&#39;t get the old aliases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Scopes.jl#L510-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.Judgment" href="#GATlab.Syntax.GATs.Judgment"><code>GATlab.Syntax.GATs.Judgment</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Judgment</code></p><p>A judgment is either a type constructor, term constructor, or axiom; a GAT is composed of a list of judgments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L271-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AbstractConstant" href="#GATlab.Syntax.GATs.AbstractConstant"><code>GATlab.Syntax.GATs.AbstractConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We need this to resolve a mutual reference loop; the only subtype is Constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAxiom" href="#GATlab.Syntax.GATs.AlgAxiom"><code>GATlab.Syntax.GATs.AlgAxiom</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgAxiom</code></p><p>A declaration of an axiom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSort" href="#GATlab.Syntax.GATs.AlgSort"><code>GATlab.Syntax.GATs.AlgSort</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSort</code></p><p>A <em>sort</em>, which is essentially a type constructor without arguments <code>ref</code> must be reference to a <code>AlgTypeConstructor</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSorts" href="#GATlab.Syntax.GATs.AlgSorts"><code>GATlab.Syntax.GATs.AlgSorts</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSorts</code></p><p>A description of the argument sorts for a term constructor, used to disambiguate multiple term constructors of the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L279-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTerm" href="#GATlab.Syntax.GATs.AlgTerm"><code>GATlab.Syntax.GATs.AlgTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTerm</code></p><p>One syntax tree to rule all the terms. Head can be a reference to an AlgTermConstructor, to a Binding{AlgType, Nothing}, or simply an AbstractConstant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTermConstructor" href="#GATlab.Syntax.GATs.AlgTermConstructor"><code>GATlab.Syntax.GATs.AlgTermConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTermConstructor</code></p><p>A declaration of a term constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgType" href="#GATlab.Syntax.GATs.AlgType"><code>GATlab.Syntax.GATs.AlgType</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgType</code></p><p>One syntax tree to rule all the types. <code>head</code> must be reference to a <code>AlgTypeConstructor</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTypeConstructor" href="#GATlab.Syntax.GATs.AlgTypeConstructor"><code>GATlab.Syntax.GATs.AlgTypeConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTypeConstructor</code></p><p>A declaration of a type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.Constant" href="#GATlab.Syntax.GATs.Constant"><code>GATlab.Syntax.GATs.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Constant</code></p><p>A Julia value in an algebraic context. Checked elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.GAT" href="#GATlab.Syntax.GATs.GAT"><code>GATlab.Syntax.GATs.GAT</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GAT</code></p><p>A generalized algebraic theory. Essentially, just consists of a name and a list of <code>GATSegment</code>s, but there is also some caching to make access faster. Specifically, there is a dictionary to map ScopeTag to position in the list of segments, and there are lists of all of the identifiers for term constructors, type constructors, and axioms so that they can be iterated through faster.</p><p>GATs allow overloading but not shadowing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L326-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.GATSegment" href="#GATlab.Syntax.GATs.GATSegment"><code>GATlab.Syntax.GATs.GATSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GATSegment</code></p><p>A piece of a GAT, consisting of a scope that binds judgments to names, possibly disambiguated by argument sorts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.JudgmentBinding" href="#GATlab.Syntax.GATs.JudgmentBinding"><code>GATlab.Syntax.GATs.JudgmentBinding</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>JudgmentBinding</code></p><p>A binding of a judgment to a name and possibly a signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.SortScope" href="#GATlab.Syntax.GATs.SortScope"><code>GATlab.Syntax.GATs.SortScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SortScope</code></p><p>A scope where variables are assigned to <code>AlgSorts</code>s, and no overloading is permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.TermInCtx" href="#GATlab.Syntax.GATs.TermInCtx"><code>GATlab.Syntax.GATs.TermInCtx</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with an accompanying type scope, e.g.</p><p><strong>(a,b)::R</strong></p><p>a*(a+b)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.TermInCtx-Tuple{GAT, Ident}" href="#GATlab.Syntax.GATs.TermInCtx-Tuple{GAT, Ident}"><code>GATlab.Syntax.GATs.TermInCtx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the canonical term associated with a term constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.TypeScope" href="#GATlab.Syntax.GATs.TypeScope"><code>GATlab.Syntax.GATs.TypeScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TypeScope</code></p><p>A scope where variables are assigned to <code>AlgType</code>s, and no overloading is permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgTerm}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgTerm}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Some expr may have already been bound (e.g. by an explicit context) and thus  oughtn&#39;t be interpreted as <code>default</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgType}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgType}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Some expr may have already been bound (e.g. by an explicit context) and thus  oughtn&#39;t be interpreted as <code>default</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Binding{AlgType, Nothing}}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Binding{AlgType, Nothing}}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return <code>nothing</code> if the binding we parse has already been bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L648-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.argcontext-Tuple{Union{AlgTermConstructor, AlgTypeConstructor}}" href="#GATlab.Syntax.GATs.argcontext-Tuple{Union{AlgTermConstructor, AlgTypeConstructor}}"><code>GATlab.Syntax.GATs.argcontext</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local context of an AlgTermConstructor, including the arguments themselves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.bind_localctx-Tuple{GAT, TermInCtx}" href="#GATlab.Syntax.GATs.bind_localctx-Tuple{GAT, TermInCtx}"><code>GATlab.Syntax.GATs.bind_localctx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a term constructor and determine terms of its local context.</p><p>This function is mutually recursive with <code>infer_type</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L555-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}" href="#GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get equations for a term or type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{Scope{AlgType, Nothing}, Scope{AlgType, Nothing}, GAT}" href="#GATlab.Syntax.GATs.equations-Tuple{Scope{AlgType, Nothing}, Scope{AlgType, Nothing}, GAT}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implicit equations defined by a context.</p><p>This function allows a generalized algebraic theory (GAT) to be expressed as an essentially algebraic theory, i.e., as partial functions whose domains are defined by equations.</p><p>References:</p><ul><li>(Cartmell, 1986, Sec 6: &quot;Essentially algebraic theories and categories with  finite limits&quot;)</li><li>(Freyd, 1972, &quot;Aspects of topoi&quot;)</li></ul><p>This function gives expressions for computing each of the elements of <code>context</code>   from the <code>args</code>, as well as checking that the args are well-typed.</p><p>Example:</p><blockquote><p>equations({f::Hom(a,b), g::Hom(b,c)}, {a::Ob, b::Ob, c::Ob}, ThCategory)</p></blockquote><p>ways<em>of</em>computing = Dict(a =&gt; [dom(f)], b =&gt; [codom(f), dom(g)], c =&gt; [codom(g)],                             f =&gt; [f], g =&gt; [g])</p><p>Algorithm:</p><p>Start from the arguments. We know how to compute each of the arguments; they are given. Each argument tells us how to compute other arguments, and also elements of the context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L420-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.infer_type-Tuple{GAT, TermInCtx}" href="#GATlab.Syntax.GATs.infer_type-Tuple{GAT, TermInCtx}"><code>GATlab.Syntax.GATs.infer_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Infer the type of the term of a term. If it is not in context, recurse on its  arguments. The term constructor&#39;s output type yields the resulting type once its localcontext variables are substituted with the relevant AlgTerms. </p><pre><code class="nohighlight hljs">          (x,y,z)::Ob, p::Hom(x,y), q::Hom(y,z)</code></pre><p>E.g. given    –––––––––––––––––––                            id(x)⋅(p⋅q)</p><pre><code class="nohighlight hljs">             (a,b,c)::Ob, f::Hom(a,b), g::Hom(b,c)</code></pre><p>and output type:  ––––––––––––––––––                               Hom(a,c)</p><p>We first recursively find <code>{id(x) =&gt; Hom(x,x), p⋅q =&gt; Hom(x,z)}</code>. We ultimately  want an AlgTerm for everything in the output type&#39;s context such that we can  substitute into <code>Hom(a,c)</code> to get the final answer. It will help to also compute  the AlgType for everything in the context. We work backwards, since we start by knowing <code>{f =&gt; id(x)::Hom(x,x), g=&gt; p⋅q :: Hom(x,z)}</code>. For <code>a</code> <code>b</code> and <code>c</code>,  we use <code>equations</code> which tell us, e.g., that <code>a = dom(f)</code>. So we can grab the  first argument of the <em>type</em> of <code>f</code> (i.e. grab <code>x</code> from <code>Hom(x,x)</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L507-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.normalize_decl-Tuple{Any}" href="#GATlab.Syntax.GATs.normalize_decl-Tuple{Any}"><code>GATlab.Syntax.GATs.normalize_decl</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>axiom=true</code> adds a <code>::default</code> to exprs like <code>f(a,b) ⊣ [a::A, b::B]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L689-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.parsetypescope-Tuple{Context, AbstractVector}" href="#GATlab.Syntax.GATs.parsetypescope-Tuple{Context, AbstractVector}"><code>GATlab.Syntax.GATs.parsetypescope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Keep track of variables already bound (e.g. in local context) so that they need not be redefined, e.g. <code>compose(f,g::Hom(b,c)) ⊣ [(a,b,c)::Ob, f::Hom(a,b)]</code> (If <code>f</code> were not defined in the local context, it would be parsed as <code>default</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L659-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgTerm)</code></p><p>Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgType)</code></p><p>Throw an error if a the head of an AlgType (which refers to a type constructor) has arguments of the wrong sort.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.GATs.substitute_term-Tuple{GATlab.Syntax.GATs.TrmTyp, Dict{Ident, AlgTerm}}" href="#GATlab.Syntax.GATs.substitute_term-Tuple{GATlab.Syntax.GATs.TrmTyp, Dict{Ident, AlgTerm}}"><code>GATlab.Syntax.GATs.substitute_term</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace idents with AlgTerms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/GATs.jl#L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.Presentations.Presentation" href="#GATlab.Syntax.Presentations.Presentation"><code>GATlab.Syntax.Presentations.Presentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A presentation has a set of generators, given by a <code>TypeScope</code>, and a set of  equations among terms which can refer to those generators. Each element of  <code>eqs</code> is a list of terms which are asserted to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Presentations.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Presentation}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Presentation}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse, e.g.:</p><pre><code class="nohighlight hljs">(a,b,c)::Ob
f::Hom(a, b)
g::Hom(b, c)
h::Hom(a, c)
h′::Hom(a, c)
compose(f, g) == h == h′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Presentations.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr-Tuple{Presentation}" href="#GATlab.Syntax.ExprInterop.toexpr-Tuple{Presentation}"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Context of presentation is the underlying GAT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/Presentations.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr" href="#GATlab.Syntax.ExprInterop.fromexpr"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fromexpr(c::Context, e::Any, T::Type) -&gt; Union{T,Nothing}</code></p><p>Converts a Julia Expr into type T, in a certain scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/ExprInterop.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr" href="#GATlab.Syntax.ExprInterop.toexpr"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>toexpr(c::Context, t) -&gt; Any</code></p><p>Converts GATlab syntax into an Expr that can be read in via <code>fromexpr</code> to get the same thing. Crucially, the output of this will depend on the order of the scopes in <code>c</code>, and if read back in with a different <code>c</code> may end up with different results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/ExprInterop.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP" href="#GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP"><code>GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>When we declare a new theory, we add the scope tag of its new segment to this dictionary pointing to the module corresponding to the new theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/syntax/TheoryInterface.jl#L36-L39">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.ImplementationNotes" href="#GATlab.Models.ModelInterface.ImplementationNotes"><code>GATlab.Models.ModelInterface.ImplementationNotes</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ImplementationNotes</code></p><p>Information about how a model implements a <code>GATSegment</code>. Right now, just the docstring attached to the <code>@instance</code> macro, but could contain more info in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag" href="#GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag"><code>GATlab.Models.ModelInterface.implements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>implements(m::Model, tag::ScopeTag) -&gt; Union{ImplementationNotes, Nothing}</code></p><p>If <code>m</code> implements the GATSegment referred to by <code>tag</code>, then return the corresponding implementation notes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr}" href="#GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr}"><code>GATlab.Models.ModelInterface.parse_instance_body</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses the raw julia expression into JuliaFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L199-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}" href="#GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}"><code>GATlab.Models.ModelInterface.qualify_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add <code>model</code> kwarg (it shouldn&#39;t have it already) Qualify method name to be in theory module Add <code>context</code> kwargs if not already present</p><p>TODO: throw error if there&#39;s junk kwargs present already?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}" href="#GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}"><code>GATlab.Models.ModelInterface.typecheck_instance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Throw error if missing a term constructor. Provides default instances for type constructors and type arguments, which return true or error, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L301-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}" href="#GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}"><code>GATlab.Models.ModelInterface.@instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Usage:</p><pre><code class="language-julia hljs">struct TypedFinSetC &lt;: Model{Tuple{Vector{Int}, Vector{Int}}}
  ntypes::Int
end

@instance ThCategory{Vector{Int}, Vector{Int}} (;model::TypedFinSetC) begin
  Ob(v::Vector{Int}) = all(1 &lt;= j &lt;= model.ntypes for j in v)
  Hom(f::Vector{Int}, v::Vector{Int}, w::Vector{Int}) =
     length(f) == length(v) &amp;&amp; all(1 &lt;= y &lt;= length(w) for y in f)

  id(v::Vector{Int}) = collect(eachindex(v))
  compose(f::Vector{Int}, g::Vector{Int}) = g[f]

  dom(f::Vector{Int}; context) = context.dom
  codom(f::Vector{Int}; context) = context.codom
end

struct SliceCat{Ob, Hom, C &lt;: Model{Tuple{Ob, Hom}}} &lt;: Model{Tuple{Tuple{Ob, Hom}, Hom}}
  c::C
end

@instance ThCategory{Tuple{Ob, Hom}, Hom} (;model::SliceCat{Ob, Hom, C}) where {Ob, Hom, C&lt;:Model{Tuple{Ob, Hom}}} begin
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/models/ModelInterface.jl#L104-L132">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils" href="#GATlab.Util.MetaUtils"><code>GATlab.Util.MetaUtils</code></a> — <span class="docstring-category">Module</span></header><section><div><p>General-purpose tools for metaprogramming in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}" href="#GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}"><code>GATlab.Util.MetaUtils.generate_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap Julia expression with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.generate_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate Julia expression for function definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L123-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia expression that is (possibly) annotated with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L49-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_function-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia function definition into standardized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.parse_function_sig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse signature of Julia function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occuring anywhere in a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L168-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occurring anywhere in a Julia function (except the name).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}" href="#GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}"><code>GATlab.Util.MetaUtils.strip_lines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove all LineNumberNodes from a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/b912ea267b59c254e4e7ab6bf85de159aca1b016/src/util/MetaUtils.jl#L179-L181">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/models/">« Model families</a><a class="docs-footer-nextpage" href="../stdlib/">Standard Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 13 September 2023 16:50">Wednesday 13 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
