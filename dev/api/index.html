<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GATlab.jl</title><meta name="title" content="Library Reference · GATlab.jl"/><meta property="og:title" content="Library Reference · GATlab.jl"/><meta property="twitter:title" content="Library Reference · GATlab.jl"/><meta name="description" content="Documentation for GATlab.jl."/><meta property="og:description" content="Documentation for GATlab.jl."/><meta property="twitter:description" content="Documentation for GATlab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GATlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/catlab_differences/">Changes from Catlab GATs</a></li><li><a class="tocitem" href="../concepts/scopes/">Scopes</a></li><li><a class="tocitem" href="../concepts/theories/">Theories</a></li><li><a class="tocitem" href="../concepts/models/">Models and instances</a></li><li><a class="tocitem" href="../concepts/symbolic_models/">Symbolic Models</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Binding" href="#GATlab.Syntax.Scopes.Binding"><code>GATlab.Syntax.Scopes.Binding</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Binding{T}</code></p><p>A binding associates some <code>T</code>-typed value to a name.</p><p><code>name</code> is an optional distinguished name <code>value</code> is the element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L205-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Context" href="#GATlab.Syntax.Scopes.Context"><code>GATlab.Syntax.Scopes.Context</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>Context</code> is anything which contains an ordered list of scopes.</p><p>Scopes within a context are referred to by <em>level</em>, which is their index within this list.</p><p><code>Context</code>s should overload:</p><ul><li><code>getscope(c::Context, level::Int) -&gt; Scope</code></li><li><code>nscopes(c::Context) -&gt; Int</code></li><li><code>hastag(c::Context, tag::ScopeTag) -&gt; Bool</code></li><li><code>hasname(c::Context, name::Symbol) -&gt; Bool</code></li><li><code>getlevel(c::Context, tag::ScopeTag) -&gt; Int</code></li><li><code>getlevel(c::Context, name::Symbol) -&gt; Int</code></li><li><code>alltags(c::Context) -&gt; Set{ScopeTag}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L295-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScope" href="#GATlab.Syntax.Scopes.HasScope"><code>GATlab.Syntax.Scopes.HasScope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An abstract type for wrappers around a single scope.</p><p>Must overload</p><p><code>getscope(hs::HasScope) -&gt; Scope</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L334-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScopeList" href="#GATlab.Syntax.Scopes.HasScopeList"><code>GATlab.Syntax.Scopes.HasScopeList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A type for things which contain a scope list.</p><p>Notably, GATs contain a scope list.</p><p>Must implement:</p><p><code>getscopelist(hsl::HasScopeList) -&gt; ScopeList</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L735-L743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Ident" href="#GATlab.Syntax.Scopes.Ident"><code>GATlab.Syntax.Scopes.Ident</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Ident</code></p><p>An identifier.</p><p><code>tag</code> refers to the scope that this Ident is bound in <code>lid</code> indexes the scope that Ident is bound in <code>name</code> is an optional field for the sake of printing. A variable in a scope might be associated with several names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.LID" href="#GATlab.Syntax.Scopes.LID"><code>GATlab.Syntax.Scopes.LID</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A LID (Local ID) indexes a given scope.</p><p>Currently, scopes assign LIDs sequentially – this is not a stable guarantee however, and in theory scopes could have &quot;sparse&quot; LIDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Scope" href="#GATlab.Syntax.Scopes.Scope"><code>GATlab.Syntax.Scopes.Scope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Scope{T}</code></p><p>In GATlab, we handle shadowing with a notion of <em>scope</em>. Names shadow between scopes. Anything which binds variables introduces a scope, for instance a <code>@theory</code> declaration or a context. For example, here is a scope with 3 elements:</p><pre><code class="nohighlight hljs">x = 3
y = &quot;hello&quot;
z = x </code></pre><p>Here z is introduced as an alias for x. It is illegal to shadow within a scope. Overloading is not explicitly treated but can be managed by having values which  refer to identifiers earlier / the present scope. See GATs.jl, for example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L371-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTag" href="#GATlab.Syntax.Scopes.ScopeTag"><code>GATlab.Syntax.Scopes.ScopeTag</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The tag that makes reference to a specific scope possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTagError" href="#GATlab.Syntax.Scopes.ScopeTagError"><code>GATlab.Syntax.Scopes.ScopeTagError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>ScopeTagError</code></p><p>An error to throw when an identifier has an unexpected scope tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopedBinding" href="#GATlab.Syntax.Scopes.ScopedBinding"><code>GATlab.Syntax.Scopes.ScopedBinding</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type for printing out bindings with colored keys</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.getidents-Tuple{HasScope}" href="#GATlab.Syntax.Scopes.getidents-Tuple{HasScope}"><code>GATlab.Syntax.Scopes.getidents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This collects all the idents in a scope</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.getlid-Tuple{HasScope, Symbol}" href="#GATlab.Syntax.Scopes.getlid-Tuple{HasScope, Symbol}"><code>GATlab.Syntax.Scopes.getlid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Determine the level of a binding given the name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L518-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.hasident-Tuple{Context}" href="#GATlab.Syntax.Scopes.hasident-Tuple{Context}"><code>GATlab.Syntax.Scopes.hasident</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>hasident</code> checks whether an identifier with specified data exists, by attempting to create it and returning whether or not that attempt failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L698-L701">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ident-Tuple{Context}" href="#GATlab.Syntax.Scopes.ident-Tuple{Context}"><code>GATlab.Syntax.Scopes.ident</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>ident</code> creates an <code>Ident</code> from a context and some partial data supplied as keywords.</p><p>Keywords arguments:</p><ul><li><code>tag::Union{ScopeTag, Nothing}</code>. The tag of the scope that the <code>Ident</code> is in.</li><li><code>name::Union{Symbol, Nothing}</code>. The name of the identifier.</li><li><code>lid::Union{LID, Nothing}</code>. The lid of the identifier within its scope.</li><li><code>level::Union{Int, Nothing}</code>. The level of the scope within the context.</li><li><code>strict::Bool</code>. If <code>strict</code> is true, throw an error if not found, else return nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L656-L665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.idents-Tuple{Context}" href="#GATlab.Syntax.Scopes.idents-Tuple{Context}"><code>GATlab.Syntax.Scopes.idents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This is a broadcasted version of <code>ident</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L711-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}" href="#GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}"><code>GATlab.Syntax.Scopes.rename</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>rename(tag::ScopeTag, replacements::Dict{Symbol, Symbol}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, and change any name <code>n</code> in scope <code>tag</code> to <code>get(replacements, n, n)</code>. Overload this function on structs that have names in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}" href="#GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}"><code>GATlab.Syntax.Scopes.retag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>retag(replacements::Dict{ScopeTag, ScopeTag}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, swapping any instance of a ScopeTag <code>t</code> with <code>get(replacements, t, t)</code>. Overload this function on structs that have ScopeTags within them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.unsafe_pushbinding!-Union{Tuple{T}, Tuple{Scope{T}, Binding{T}}} where T" href="#GATlab.Syntax.Scopes.unsafe_pushbinding!-Union{Tuple{T}, Tuple{Scope{T}, Binding{T}}} where T"><code>GATlab.Syntax.Scopes.unsafe_pushbinding!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Add a new binding to the end of Scope <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/Scopes.jl#L486-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AbstractConstant" href="#GATlab.Syntax.GATs.AbstractConstant"><code>GATlab.Syntax.GATs.AbstractConstant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>We need this to resolve a mutual reference loop; the only subtype is Constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AbstractDot" href="#GATlab.Syntax.GATs.AbstractDot"><code>GATlab.Syntax.GATs.AbstractDot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>We need this to resolve a mutual reference loop; the only subtype is Dot</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAccessor" href="#GATlab.Syntax.GATs.AlgAccessor"><code>GATlab.Syntax.GATs.AlgAccessor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgAccessor</code></p><p>The arguments to a term constructor serve a dual function as both arguments and also methods to extract the value of those arguments.</p><p>I.e., declaring <code>Hom(dom::Ob, codom::Ob)::TYPE</code> implicitly overloads a previous declaration for <code>dom</code> and <code>codom</code>, or creates declarations if none previously exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L84-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAxiom" href="#GATlab.Syntax.GATs.AlgAxiom"><code>GATlab.Syntax.GATs.AlgAxiom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgAxiom</code></p><p>A declaration of an axiom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgDeclaration" href="#GATlab.Syntax.GATs.AlgDeclaration"><code>GATlab.Syntax.GATs.AlgDeclaration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgDeclaration</code></p><p>A declaration of a constructor; constructor methods in the form of <code>AlgTermConstructors</code> or the accessors for <code>AlgTypeConstructors</code> follow later in the theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgDot" href="#GATlab.Syntax.GATs.AlgDot"><code>GATlab.Syntax.GATs.AlgDot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Accessing a name from a term of tuple type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L248-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgEqSort" href="#GATlab.Syntax.GATs.AlgEqSort"><code>GATlab.Syntax.GATs.AlgEqSort</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgSort</code></p><p>A sort for equality judgments of terms for a particular sort</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgFunction" href="#GATlab.Syntax.GATs.AlgFunction"><code>GATlab.Syntax.GATs.AlgFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A shorthand for a function, such as &quot;square(x) := x * x&quot;.  It is relevant for  models but can be ignored by theory maps, as it is fully determined by other  judgments in the theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSort" href="#GATlab.Syntax.GATs.AlgSort"><code>GATlab.Syntax.GATs.AlgSort</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgSort</code></p><p>A <em>sort</em>, which is essentially a type constructor without arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgStruct" href="#GATlab.Syntax.GATs.AlgStruct"><code>GATlab.Syntax.GATs.AlgStruct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgStruct</code></p><p>A declaration which is sugar for an AlgTypeConstructor, an AlgTermConstructor  which constructs an element of that type, and projection term constructors. E.g.</p><pre><code class="nohighlight hljs">struct Cospan(dom, codom) ⊣ [dom:Ob, codom::Ob]
  apex::Ob
  i1::dom-&gt;apex
  i2::codom-&gt;apex
end</code></pre><p>Is tantamount to (in a vanilla GAT):</p><pre><code class="nohighlight hljs">Cospan(dom::Ob, codom::Ob)::TYPE 

cospan(apex, i1, i2)::Cospan(dom, codom) 
  ⊣ [(dom, codom, apex)::Ob, i1::dom-&gt;apex, i2::codom-&gt;apex]

apex(csp::Cospan(d::Ob, c::Ob))::Ob            
i1(csp::Cospan(d::Ob, c::Ob))::(d-&gt;apex(csp))
i2(csp::Cospan(d::Ob, c::Ob))::(c-&gt;apex(csp))

apex(cospan(a, i_1, i_2)) == a  
  ⊣ [(dom, codom, apex)::Ob, i_1::dom-&gt;apex, i_2::codom-&gt;apex]
i1(cospan(a, i_1, i_2)) == i_1 
  ⊣ [(dom, codom, apex)::Ob, i_1::dom-&gt;apex, i_2::codom-&gt;apex]
i2(cospan(a, i_1, i_2)) == i_2
  ⊣ [(dom, codom, apex)::Ob, i_1::dom-&gt;apex, i_2::codom-&gt;apex]

cospan(apex(csp), i1(csp), i2(csp)) == csp
  ⊣ [(dom, codom)::Ob, csp::Cospan(dom, codom)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L171-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTerm" href="#GATlab.Syntax.GATs.AlgTerm"><code>GATlab.Syntax.GATs.AlgTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgTerm</code></p><p>One syntax tree to rule all the terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTermConstructor" href="#GATlab.Syntax.GATs.AlgTermConstructor"><code>GATlab.Syntax.GATs.AlgTermConstructor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgTermConstructor</code></p><p>A declaration of a term constructor as a method of an <code>AlgFunction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgType" href="#GATlab.Syntax.GATs.AlgType"><code>GATlab.Syntax.GATs.AlgType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgType</code></p><p>One syntax tree to rule all the types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTypeConstructor" href="#GATlab.Syntax.GATs.AlgTypeConstructor"><code>GATlab.Syntax.GATs.AlgTypeConstructor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>AlgTypeConstructor</code></p><p>A declaration of a type constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Constant" href="#GATlab.Syntax.GATs.Constant"><code>GATlab.Syntax.GATs.Constant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Constant</code></p><p>A Julia value in an algebraic context. Type checked elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Eq" href="#GATlab.Syntax.GATs.Eq"><code>GATlab.Syntax.GATs.Eq</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Eq</code></p><p>The type of equality judgments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GAT" href="#GATlab.Syntax.GATs.GAT"><code>GATlab.Syntax.GATs.GAT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>GAT</code></p><p>A generalized algebraic theory. Essentially, just consists of a name and a list of <code>GATSegment</code>s, but there is also some caching to make access faster. Specifically, there is a dictionary to map ScopeTag to position in the list of segments, and there are lists of all of the identifiers for term constructors, type constructors, and axioms so that they can be iterated through faster.</p><p>GATs allow overloading but not shadowing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/gat.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GATContext" href="#GATlab.Syntax.GATs.GATContext"><code>GATlab.Syntax.GATs.GATContext</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>GATContext</code></p><p>A context consisting of two parts: a GAT and a TypeCtx</p><p>Certain types (like AlgTerm) can only be parsed in a GATContext, because they require access to the method resolving in the GAT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/gat.jl#L351-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GATSegment" href="#GATlab.Syntax.GATs.GATSegment"><code>GATlab.Syntax.GATs.GATSegment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>GATSegment</code></p><p>A piece of a GAT, consisting of a scope that binds judgments to names, possibly disambiguated by argument sorts.</p><p>This is a struct rather than just a type alias so that we can customize the show method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/gat.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.InCtx-Union{Tuple{AlgType}, Tuple{GAT, Ident}} where AlgType" href="#GATlab.Syntax.GATs.InCtx-Union{Tuple{AlgType}, Tuple{GAT, Ident}} where AlgType"><code>GATlab.Syntax.GATs.InCtx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the canonical type + ctx associated with a type constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L160-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.InCtx-Union{Tuple{T}, Tuple{GAT, Ident}} where T&lt;:AlgAST" href="#GATlab.Syntax.GATs.InCtx-Union{Tuple{T}, Tuple{GAT, Ident}} where T&lt;:AlgAST"><code>GATlab.Syntax.GATs.InCtx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the canonical term + ctx associated with a method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L151-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Judgment" href="#GATlab.Syntax.GATs.Judgment"><code>GATlab.Syntax.GATs.Judgment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A GAT is conceptually a bunch of <code>Judgment</code>s strung together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.MethodApp" href="#GATlab.Syntax.GATs.MethodApp"><code>GATlab.Syntax.GATs.MethodApp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>MethodApp</code></p><p>An application of a method of a constructor to arguments. We need a type parameter <code>T</code> because <code>AlgTerm</code> hasn&#39;t been defined yet, but the only type used for <code>T</code> will in fact be <code>AlgTerm</code>.</p><p><code>method</code> either points to an <code>AlgTermConstructor</code>, an <code>AlgTypeConstructor</code> or an <code>AlgAccessor</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.MethodResolver" href="#GATlab.Syntax.GATs.MethodResolver"><code>GATlab.Syntax.GATs.MethodResolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>MethodResolver</code></p><p>Right now, this just maps a sort signature to the resolved method.</p><p>When we eventually support varargs, this will have to do something slightly fancier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/gat.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.TypeScope" href="#GATlab.Syntax.GATs.TypeScope"><code>GATlab.Syntax.GATs.TypeScope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>TypeScope</code></p><p>A scope where variables are assigned to <code>AlgType</code>s. We use a wrapper here so that it pretty prints as <code>[a::B]</code> instead of <code>{a =&gt; AlgType(B)}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/judgments.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.equations-Tuple{GAT, Ident}" href="#AlgebraicInterfaces.equations-Tuple{GAT, Ident}"><code>AlgebraicInterfaces.equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get equations for a term or type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.equations-Tuple{GATContext, AbstractVector{Ident}}" href="#AlgebraicInterfaces.equations-Tuple{GATContext, AbstractVector{Ident}}"><code>AlgebraicInterfaces.equations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implicit equations defined by a context.</p><p>This function allows a generalized algebraic theory (GAT) to be expressed as an essentially algebraic theory, i.e., as partial functions whose domains are defined by equations.</p><p>References:</p><ul><li>(Cartmell, 1986, Sec 6: &quot;Essentially algebraic theories and categories with  finite limits&quot;)</li><li>(Freyd, 1972, &quot;Aspects of topoi&quot;)</li></ul><p>This function gives expressions for computing the elements of <code>c.context</code>   which can be inferred from applying accessor functions to elements of <code>args</code>.</p><p>Example:</p><blockquote><p>equations({f::Hom(a,b), g::Hom(b,c)}, {a::Ob, b::Ob, c::Ob}, ThCategory)</p></blockquote><p>ways<em>of</em>computing = Dict(a =&gt; [dom(f)], b =&gt; [codom(f), dom(g)], c =&gt; [codom(g)],                          f =&gt; [f], g =&gt; [g])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L47-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Union{Tuple{T}, Tuple{IO, T}} where T&lt;:Union{AlgTerm, AlgType}" href="#Base.show-Union{Tuple{T}, Tuple{IO, T}} where T&lt;:Union{AlgTerm, AlgType}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Common methods for AlgType and AlgTerm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/ast.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{GAT, Any, Any}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{GAT, Any, Any}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Coerce GATs to GAT contexts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/exprinterop.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr-Tuple{GAT, GATSegment}" href="#GATlab.Syntax.ExprInterop.toexpr-Tuple{GAT, GATSegment}"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This only works when <code>seg</code> is a segment of <code>theory</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/exprinterop.jl#L413-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.normalize_judgment-Tuple{Any}" href="#GATlab.Syntax.GATs.normalize_judgment-Tuple{Any}"><code>GATlab.Syntax.GATs.normalize_judgment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This is necessary because the intuitive precedence rules for the symbols that we use do not match the Julia precedence rules. In theory, this could be written with some algorithm that recalculates precedence, but I am too lazy to write that, so instead I just special case everything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/exprinterop.jl#L324-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.parse_scope!-Tuple{Function, Scope, AbstractVector}" href="#GATlab.Syntax.GATs.parse_scope!-Tuple{Function, Scope, AbstractVector}"><code>GATlab.Syntax.GATs.parse_scope!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>f(pushbinding!, expr)</code> should inspect <code>expr</code> and call <code>pushbinding!</code> 0 or more times with two arguments: the name and value of a new binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/exprinterop.jl#L198-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgTerm)</code></p><p>Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgType)</code></p><p>Throw an error if a the head of an AlgType (which refers to a type constructor) has arguments of the wrong sort.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.structs-Tuple{GAT}" href="#GATlab.Syntax.GATs.structs-Tuple{GAT}"><code>GATlab.Syntax.GATs.structs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get all structs in a theory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/gat.jl#L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.substitute_funs-Tuple{Context, AlgTerm}" href="#GATlab.Syntax.GATs.substitute_funs-Tuple{Context, AlgTerm}"><code>GATlab.Syntax.GATs.substitute_funs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Replace all functions with their desugared expressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.substitute_term-Union{Tuple{T}, Tuple{T, Dict{Ident, AlgTerm}}} where T&lt;:AlgAST" href="#GATlab.Syntax.GATs.substitute_term-Union{Tuple{T}, Tuple{T, Dict{Ident, AlgTerm}}} where T&lt;:AlgAST"><code>GATlab.Syntax.GATs.substitute_term</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Replace idents with AlgTerms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/gats/algorithms.jl#L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{GATContext, Any, Type{GATContext}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{GATContext, Any, Type{GATContext}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parse, e.g.:</p><pre><code class="nohighlight hljs">(a,b,c)::Ob
f::Hom(a, b)
g::Hom(b, c)
h::Hom(a, c)
h′::Hom(a, c)
compose(f, g) == h == h′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/GATContexts.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATContexts.@symbolic-Tuple{Any, Any}" href="#GATlab.Syntax.GATContexts.@symbolic-Tuple{Any, Any}"><code>GATlab.Syntax.GATContexts.@symbolic</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@symbolic ThRing function v(a, b, c)
  (a*b, c, b)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/GATContexts.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr" href="#GATlab.Syntax.ExprInterop.fromexpr"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>fromexpr(c::Context, e::Any, T::Type) -&gt; Union{T,Nothing}</code></p><p>Converts a Julia Expr into type T, in a certain scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/ExprInterop.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr" href="#GATlab.Syntax.ExprInterop.toexpr"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>toexpr(c::Context, t) -&gt; Any</code></p><p>Converts GATlab syntax into an Expr that can be read in via <code>fromexpr</code> to get the same thing. Crucially, the output of this will depend on the order of the scopes in <code>c</code>, and if read back in with a different <code>c</code> may end up with different results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/ExprInterop.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface" href="#GATlab.Syntax.TheoryInterface"><code>GATlab.Syntax.TheoryInterface</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Each theory corresponds to a module, which has the following items.</p><p>For each new term constructor in the theory, a newly declared function with the name of that term constructor.</p><p>For each new type constructor in the theory, a newly declared function with the name of that type constructor.</p><p>For each type parameter to a new type constructor in the theory, a function with the name of that type parameter.</p><p>For all of the old term constructors/type constructors/type parameters, imports from the modules that define them.</p><p>For all aliases, <code>const</code> declarations that make them equal to their primaries.</p><p>A macro called <code>@theory</code> which expands to the <code>GAT</code> data structure for the module.</p><p>A constant called <code>Meta.theory</code> which is the <code>GAT</code> data structure.</p><p>A struct called <code>Meta.Wrapper</code> which is a smart constructor for Julia types  which implement the theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP" href="#GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP"><code>GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>When we declare a new theory, we add the scope tag of its new segment to this dictionary pointing to the module corresponding to the new theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.Dispatch" href="#GATlab.Syntax.TheoryInterface.Dispatch"><code>GATlab.Syntax.TheoryInterface.Dispatch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The Dispatch model defers to type-dispatch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L205-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.InitialModel′" href="#GATlab.Syntax.TheoryInterface.InitialModel′"><code>GATlab.Syntax.TheoryInterface.InitialModel′</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The Initial model assigns <code>Union{}</code> to all AlgSorts. There is one implementation for any given theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L221-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.TerminalModel′" href="#GATlab.Syntax.TheoryInterface.TerminalModel′"><code>GATlab.Syntax.TheoryInterface.TerminalModel′</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The Terminal model assigns <code>Nothing</code> to all AlgSorts. There is one  implementation for any given theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.expand_theory-Tuple{Any, Any, Any}" href="#GATlab.Syntax.TheoryInterface.expand_theory-Tuple{Any, Any, Any}"><code>GATlab.Syntax.TheoryInterface.expand_theory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Accepts a name, a theory body and returns a theory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.fqmn-Tuple{Module}" href="#GATlab.Syntax.TheoryInterface.fqmn-Tuple{Module}"><code>GATlab.Syntax.TheoryInterface.fqmn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Fully Qualified Module Name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.mdp-Tuple{Nothing}" href="#GATlab.Syntax.TheoryInterface.mdp-Tuple{Nothing}"><code>GATlab.Syntax.TheoryInterface.mdp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parse markdown coming out of @doc programatically. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.mk_struct-Tuple{AlgStruct, Any}" href="#GATlab.Syntax.TheoryInterface.mk_struct-Tuple{AlgStruct, Any}"><code>GATlab.Syntax.TheoryInterface.mk_struct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/syntax/TheoryInterface.jl#L280-L282">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface" href="#GATlab.Models.ModelInterface"><code>GATlab.Models.ModelInterface</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Any Julia struct can be a model of a GAT. A model <code>m::M</code> is marked as  implementing a theory iff, for all operations f(::A,::B,...), we have:</p><p><code>hasmethod(f, (WithModel{M}, A, B) == true</code></p><p>Then we expect the following.</p><p>Let <code>M</code> be the module corresponding to <code>seg</code>.</p><p>Then for each type constructor <code>ty</code> in <code>seg</code>, we must overload</p><p><code>M.ty(wm::WithModel{typeof(m)}, x, args...; context::Union{Nothing, NamedTuple})::Bool</code></p><p>to attempt to coerce <code>x</code> to a valid element of <code>tc(args...)</code> with explicit context <code>context</code> according to <code>m</code> (it is rare that you need a context for a type constructor; notable examples include 2-cells for a bicategory).</p><p>For each argument <code>a</code> to <code>ty</code>, we must overload</p><p><code>M.a(wm::WithModel{typeof(m)}, x;, context::Union{Nothing, NamedTuple})</code></p><p>to either error or return the argument <code>a</code> of <code>x</code>. It is perfectly valid for this to always error, (e.g. CSetTransformations which do  not store their domain / codomain) but it is sometimes useful and convenient to define this, and additionally sometimes necessary for backwards compatibility.</p><p>Finally, for each term constructor <code>tc</code> in <code>seg</code>, we must overload</p><p><code>M.tc(wm::WithModel{typeof(m)}, args...; context::Union{Nothing, NamedTuple})</code></p><p>to apply the term constructor to the args. The implementation of <code>M.tc</code> should do no validity checking; that should be assumed to have already been done. In general, it is acceptable to error if <code>context</code> does not contain every element of the context. However, one may in fact only need certain elements of <code>context</code>, and so it is possible to get away without providing the context when you are writing code that is not generic across models, and you know that, for instance, composition of FinFunctions does not need the domains and codomains of the FinFunctions explicitly supplied.</p><p>A model implements a theory iff it implements all of the GATSegments in the theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L2-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.default_instance-NTuple{4, Any}" href="#GATlab.Models.ModelInterface.default_instance-NTuple{4, Any}"><code>GATlab.Models.ModelInterface.default_instance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create an @instance for a model <code>M</code> whose methods are determined by type  dispatch, e.g.:</p><pre><code class="nohighlight hljs">@instance ThCategory{O,H} [model::M] begin
  id(x::O) = id(x)
  compose(f::H, g::H)::H = compose(f, g)
end</code></pre><p>Use this with caution! For example, using this with two different models of  the same theory with the same types would cause a conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L730-L743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.default_model-NTuple{4, Any}" href="#GATlab.Models.ModelInterface.default_model-NTuple{4, Any}"><code>GATlab.Models.ModelInterface.default_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create an @instance for a model <code>M</code> whose methods are determined by the  implementation of another model, <code>M2</code>, e.g.:</p><pre><code class="nohighlight hljs">@instance ThCategory{O,H} [model::M] begin
  id(x::O) = id[M2](x)
  compose(f::H, g::H)::H = compose[M2](f, g)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L755-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.make_alias_definitions" href="#GATlab.Models.ModelInterface.make_alias_definitions"><code>GATlab.Models.ModelInterface.make_alias_definitions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns two lists of JuliaFunctions: one for aliases of type constructors, one  for aliases of term constructors.</p><p>Optional <code>methodnames</code> argument restricts aliases to only being generated if the  name they are an alias for is included in this list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L421-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.migrate_model" href="#GATlab.Models.ModelInterface.migrate_model"><code>GATlab.Models.ModelInterface.migrate_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a theory map A -&gt; B, construct a new struct type which wraps a model of theory B and is itself a model of theory A. The name of the struct can be optionally given, otherwise it is gensym&#39;d. The resulting expression is an instance of that struct type.</p><p>Future work: There is some subtlety in how accessor functions should be handled. TODO: The new instance methods do not yet handle the <code>context</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L585-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr, GAT}" href="#GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr, GAT}"><code>GATlab.Models.ModelInterface.parse_instance_body</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parses the raw julia expression into JuliaFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L307-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any, Any}" href="#GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any, Any}"><code>GATlab.Models.ModelInterface.qualify_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Add <code>WithModel</code> param first, if this is not an old instance (it shouldn&#39;t have it already) Qualify method name to be in theory module Qualify args to struct types Add <code>context</code> kwargs if not already present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L467-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.to_call_impl-Tuple{AlgTerm, GAT, Union{Module, Symbol}, Vector{Symbol}, Bool}" href="#GATlab.Models.ModelInterface.to_call_impl-Tuple{AlgTerm, GAT, Union{Module, Symbol}, Vector{Symbol}, Bool}"><code>GATlab.Models.ModelInterface.to_call_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compile an AlgTerm into a Julia call Expr where termcons (e.g. <code>f</code>) are interpreted as <code>mod.f[model.model](...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L693-L696">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.typecheck_runtime-Tuple{Any, GAT, Any, Any, Ident, Any}" href="#GATlab.Models.ModelInterface.typecheck_runtime-Tuple{Any, GAT, Any, Any, Ident, Any}"><code>GATlab.Models.ModelInterface.typecheck_runtime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check if a method exists </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.use_dispatch_method_impl-Tuple{Ident, GAT, Dict{AlgSort}}" href="#GATlab.Models.ModelInterface.use_dispatch_method_impl-Tuple{Ident, GAT, Dict{AlgSort}}"><code>GATlab.Models.ModelInterface.use_dispatch_method_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A canonical implementation that just calls the method with type dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L814-L816">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.use_model_method_impl-Tuple{Ident, GAT, Dict{AlgSort}, Union{Expr, Symbol}}" href="#GATlab.Models.ModelInterface.use_model_method_impl-Tuple{Ident, GAT, Dict{AlgSort}, Union{Expr, Symbol}}"><code>GATlab.Models.ModelInterface.use_model_method_impl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A canonical implementation that just calls the method with the implementation of another model, <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L800-L803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.impl_type-Tuple{Any, Ident}" href="#GATlab.Syntax.TheoryInterface.impl_type-Tuple{Any, Ident}"><code>GATlab.Syntax.TheoryInterface.impl_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If <code>m</code> implements a GAT with a type constructor (identified by ident <code>id</code>),  mapped to a Julia type, this function returns that Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L120-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.impl_type-Tuple{Any, Module, Symbol}" href="#GATlab.Syntax.TheoryInterface.impl_type-Tuple{Any, Module, Symbol}"><code>GATlab.Syntax.TheoryInterface.impl_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This can error if called on a symbol that matches a declaration that has more than one method </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.implements" href="#GATlab.Syntax.TheoryInterface.implements"><code>GATlab.Syntax.TheoryInterface.implements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Check whether a model implements a particular theory.</p><p>If no types are provided, then we look up whether or not <code>impl_type</code> methods  exist for this model + theory. If not, we will get a MethodError and assume  that the model does not implement the theory. (WARNING: occasionally one has  a complex type, such as <code>foo(Int,String)</code> which itself leads to a MethodError,  and this can be confusing because it looks like the model doesn&#39;t implement the theory at all rather than just being an error in how it was implemented).</p><p>Once types are provided, we can check whether the theory is implemented by  checking for each term constructor whether or not the model implements that (handled by a different <code>implements</code> method).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.implements-Tuple{Any, Module, Ident, Vector{&lt;:Type}}" href="#GATlab.Syntax.TheoryInterface.implements-Tuple{Any, Module, Ident, Vector{&lt;:Type}}"><code>GATlab.Syntax.TheoryInterface.implements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Machine-friendly access to checking if a model implements a particular operation. The <code>types</code> vector is in bijection with the AlgSorts of the <em>whole theory</em>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.implements-Union{Tuple{T}, Tuple{T, Module, Symbol}, Tuple{T, Module, Symbol, Any}} where T" href="#GATlab.Syntax.TheoryInterface.implements-Union{Tuple{T}, Tuple{T, Module, Symbol}, Tuple{T, Module, Symbol, Any}} where T"><code>GATlab.Syntax.TheoryInterface.implements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>User-friendly access to checking if a model implements an operation.</p><p>Throws an error if the name is overloaded. Anything programmatic should be  calling a method which accepts method <code>Ident</code>s rather than <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}" href="#GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}"><code>GATlab.Models.ModelInterface.@instance</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Usage:</p><pre><code class="language-julia hljs">struct TypedFinSetC
  ntypes::Int
end

@instance ThCategory{Vector{Int}, Vector{Int}} [model::TypedFinSetC] begin
  Ob(v::Vector{Int}) = all(1 &lt;= j &lt;= model.ntypes for j in v)
  Hom(f::Vector{Int}, v::Vector{Int}, w::Vector{Int}) =
     length(f) == length(v) &amp;&amp; all(1 &lt;= y &lt;= length(w) for y in f)

  id(v::Vector{Int}) = collect(eachindex(v))
  compose(f::Vector{Int}, g::Vector{Int}) = g[f]

  dom(f::Vector{Int}; context) = context.dom
  codom(f::Vector{Int}; context) = context.codom
end

struct SliceC{ObT, HomT, C}
  cat::C
  over::ObT
  function SliceC(cat::C, over) where C
    implements(cat, ThCategory) || error(&quot;Bad cat cat&quot;)
    obtype = impl_type(cat, ThCategory, :Ob)
    homtype = impl_type(cat, ThCategory, :Hom)
    new{obtype, homtype, C}(cat, ThCategory.Ob[cat](over))
  end
end

@instance ThCategory{Tuple{Ob, Hom}, Hom} [model::SliceCat{Ob, Hom, C}] where {Ob, Hom, C}}} begin
  ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/ModelInterface.jl#L142-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.GATExpr" href="#GATlab.Models.SymbolicModels.GATExpr"><code>GATlab.Models.SymbolicModels.GATExpr</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Base type for expressions in the syntax of a GAT. This is an alternative to <code>AlgTerm</code> used for backwards compatibility with Catlab.</p><p>We define Julia types for each <em>type constructor</em> in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia&#39;s type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)</p><p>The concrete types are structurally similar to the core type <code>Expr</code> in Julia. However, the <em>term constructor</em> is represented as a type parameter, rather than as a <code>head</code> field. This makes dispatch using Julia&#39;s type system more convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.nameof-Tuple{GATExpr{:generator}}" href="#Base.nameof-Tuple{GATExpr{:generator}}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get name of GAT generator expression as a <code>Symbol</code>.</p><p>If the generator has no name, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.constructor_name</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Name of constructor that created expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L518-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}" href="#GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Functor from GAT expression to GAT instance.</p><p>Strictly speaking, we should call these &quot;structure-preserving functors&quot; or, better, &quot;model homomorphisms of GATs&quot;. But this is a category theory library, so we&#39;ll go with the simpler &quot;functor&quot;.</p><p>A functor is completely determined by its action on the generators. There are several ways to specify this mapping:</p><ol><li><p>Specify a Julia instance type for each GAT type, using the required <code>types</code> tuple. For this to work, the generator constructors must be defined for the instance types.</p></li><li><p>Explicitly map each generator term to an instance value, using the <code>generators</code> dictionary.</p></li><li><p>For each GAT type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the <code>terms</code> dictionary.</p></li></ol><p>The <code>terms</code> dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.</p><p>FIXME</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L539-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.generator_like-Tuple{GATExpr, Any}" href="#GATlab.Models.SymbolicModels.generator_like-Tuple{GATExpr, Any}"><code>GATlab.Models.SymbolicModels.generator_like</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create generator of the same type as the given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L529-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}" href="#GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}"><code>GATlab.Models.SymbolicModels.parse_json_sexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Deserialize expression from JSON-able S-expression.</p><p>If <code>symbols</code> is true (the default), strings are converted to symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L612-L616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_latex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Show the expression in infix notation using LaTeX math.</p><p>Does <em>not</em> include <code>$</code> or <code>\[begin|end]{equation}</code> delimiters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L693-L697">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_sexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Show the syntax expression as an S-expression.</p><p>Cf. the standard library function <code>Meta.show_sexpr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L651-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_unicode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Show the expression in infix notation using Unicode symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L668-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}" href="#GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}"><code>GATlab.Models.SymbolicModels.symbolic_instance_methods</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Julia function for every type constructor, accessor, and term constructor. Term constructors can be overwritten by <code>overrides</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L418-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.syntax_module</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get syntax module of given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L523-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.to_json_sexpr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Serialize expression as JSON-able S-expression.</p><p>The format is an S-expression encoded as JSON, e.g., &quot;compose(f,g)&quot; is represented as [&quot;compose&quot;, f, g].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L596-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}" href="#GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}"><code>GATlab.Models.SymbolicModels.@symbolic_model</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>@symbolic_model generates the free model of a theory, generated by symbols.</p><p>This is backwards compatible with the @syntax macro in Catlab.</p><p>One way of thinking about this is that for every type constructor, we add an additional term constructor that builds a &quot;symbolic&quot; element of that type from any Julia value. This term constructor is called &quot;generator&quot;.</p><p>An invocation of <code>@symbolic_model</code> creates the following.</p><ol><li>A module with a struct for each type constructor, which has a single type</li></ol><p>parameter <code>T</code> and two fields, <code>args</code> and <code>type_args</code>. Instances of this struct are thought of as elements of the type given by the type constructor applied to <code>type_args</code>. The type parameter refers to the term constructor that was used to generate the element, including the special term constructor <code>:generator</code>, which has as its single argument an <code>Any</code>.</p><p>For instance, in the theory of categories, we might have the following elements.</p><pre><code class="nohighlight hljs">using .FreeCategory
x = Ob{:generator}([:x], [])
y = Ob{:generator}([:y], [])
f = Hom{:generator}([:f], [x, y])
g = Hom{:generator}([:g], [y, x])
h = Hom{:compose}([f, g], [x, x])</code></pre><ol><li>Methods inside the module (not exported) for all of the term constructors and</li></ol><p>field accessors (i.e. stuff like <code>compose, id, dom, codom</code>), which construct terms.</p><ol><li>A default instance (i.e., without a model parameter) of the theory using the</li></ol><p>types in this generated model. Methods in this instance can be overridden by the body of <code>@symbolic_model</code> to perform rewriting for the sake of normalization, for instance flattening associative and unital operations.</p><ol><li>Coercion methods of the type constructors that allow one to introduce generators.</li></ol><pre><code class="nohighlight hljs">x = ThCategory.Ob(FreeCategory.Ob, :x)
y = ThCategory.Ob(FreeCategory.Ob, :y)
f = ThCategory.Hom(:f, x, y)</code></pre><p>Note that in both the instance and in these coercion methods, we must give the expected type as the first argument when it cannot be infered by the other arguments. For instance, instead of</p><pre><code class="nohighlight hljs">munit() = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">munit(::Type{FreeSMC.Ob}) = ...</code></pre><p>and likewise instead of</p><pre><code class="nohighlight hljs">ThCategory.Ob(x::Any) = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">ThCategory.Ob(::Type{FreeCategory.Ob}, x::Any) = ...</code></pre><p>Example:</p><pre><code class="language-julia hljs">@symbolic_model FreeCategory{ObExr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate_unit(new(f,g; strict=true), id)
end</code></pre><p>This generates:</p><pre><code class="language-julia hljs">module FreeCategory
export Ob, Hom
using ..__module__

module Meta
  const theory_module = ThCategory
  const theory = ThCategory.Meta.theory
  const theory_type = ThCategory.Meta.T
end

struct Ob{T} &lt;: __module__.ObExpr{T} # T is :generator or a Symbol
  args::Vector
  type_args::Vector{GATExpr}
end

struct Hom{T} &lt;: __module__.HomExpr{T}
  args::Vector
  type_args::Vector{GATExpr}
end

dom(x::Hom) = x.type_args[1]

codom(x::Hom) = x.type_args[2]

function compose(f::Hom, g::Hom; strict=true)
  if strict &amp;&amp; !(codom(f) == dom(g))
    throw(SyntaxDomainError(:compose, [f, g]))
  end
  Hom{:compose}([f, g], [dom(f), codom(g)])
end

function id(x::Ob)
  Ob{:id}([x], [x, x])
end
end

# default implementations 

function ThCategory.dom(x::FreeCategory.Hom)::FreeCategory.Ob
  FreeCategory.dom(x)
end

function ThCategory.Ob(::Type{FreeCategory.Ob}, __value__::Any)::FreeCategory.Ob
  FreeCategory.Ob{:generator}([__value__], [])
end

function ThCategory.id(A::FreeCategory.Ob)::FreeCategory.Hom
  FreeCategory.id(A)
end

function ThCategory.compose(f::FreeCategory.Hom, g::FreeCategory.Hom; strict=true)
  associate_unit(FreeCategory.compose(f, g; strict), id)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/models/SymbolicModels.jl#L94-L231">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils" href="#GATlab.Util.MetaUtils"><code>GATlab.Util.MetaUtils</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>General-purpose tools for metaprogramming in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.JuliaFunctionSigNoWhere" href="#GATlab.Util.MetaUtils.JuliaFunctionSigNoWhere"><code>GATlab.Util.MetaUtils.JuliaFunctionSigNoWhere</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>For comparing JuliaFunctionSigs modulo the where parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.concat_expr-Tuple{Expr, Expr}" href="#GATlab.Util.MetaUtils.concat_expr-Tuple{Expr, Expr}"><code>GATlab.Util.MetaUtils.concat_expr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Concatenate two Julia expressions into a block expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L211-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}" href="#GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}"><code>GATlab.Util.MetaUtils.generate_docstring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrap Julia expression with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L138-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.generate_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate Julia expression for function definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_docstring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parse Julia expression that is (possibly) annotated with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_function-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parse Julia function definition into standardized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.parse_function_sig</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Parse signature of Julia function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L125-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Replace symbols occuring anywhere in a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L236-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Replace symbols occurring anywhere in a Julia function (except the name).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}" href="#GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}"><code>GATlab.Util.MetaUtils.strip_lines</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Remove all LineNumberNodes from a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/92f194e60342c1d3af481d7989ce42832df7dfc2/src/util/MetaUtils.jl#L247-L249">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/symbolic_models/">« Symbolic Models</a><a class="docs-footer-nextpage" href="../stdlib/">Standard Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 12 March 2025 16:58">Wednesday 12 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
