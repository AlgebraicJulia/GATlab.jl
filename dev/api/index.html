<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · Gatlab.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gatlab.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Gatlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/overview/">For Catlab users</a></li><li><a class="tocitem" href="../concepts/theories/">Theories</a></li><li><a class="tocitem" href="../concepts/models/">Model families</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li><li><a class="tocitem" href="../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Util.Names.Name" href="#Gatlab.Util.Names.Name"><code>Gatlab.Util.Names.Name</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Names are used to label parts of a GAT.</p><p>They are used for both human input and output of a GAT, but are not used internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/util/Names.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Util.Names.SymLit" href="#Gatlab.Util.Names.SymLit"><code>Gatlab.Util.Names.SymLit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We have a symbol wrapper because we get symbols from parsing, and it is faster to compare symbols than it is to compare strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/util/Names.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.AbstractTheory" href="#Gatlab.Syntax.Theories.AbstractTheory"><code>Gatlab.Syntax.Theories.AbstractTheory</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A type-level signifier for a particular theory, used to control dispatch and to pass around theory objects (which can&#39;t be type parameters) at the type level.</p><p>Structs which subtype <code>AbstractTheory</code> should always be singletons, and have <code>theory</code> defined on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L212-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.AnonTrmTag" href="#Gatlab.Syntax.Theories.AnonTrmTag"><code>Gatlab.Syntax.Theories.AnonTrmTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This can be used when there isn&#39;t a specific struct like <code>Category.compose</code>. Specific structs are preferred because they make reading backtraces easier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L150-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.AnonTypTag" href="#Gatlab.Syntax.Theories.AnonTypTag"><code>Gatlab.Syntax.Theories.AnonTypTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This can be used when there isn&#39;t a specific struct like <code>Category.Ob</code>. Specific structs are preferred because they make reading backtraces easier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.FullContext" href="#Gatlab.Syntax.Theories.FullContext"><code>Gatlab.Syntax.Theories.FullContext</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The full context for a <code>Trm</code> or <code>Typ</code> consists of both the list of judgments in the theory, and also the list of judgments in the context.</p><p>TODO: maybe we should have different terms for &quot;context judgment&quot; and &quot;theory judgment&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L179-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.Lvl" href="#Gatlab.Syntax.Theories.Lvl"><code>Gatlab.Syntax.Theories.Lvl</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The tag of a Lvl takes up two bits and can be three things:</p><p>00: part of the theory 01: part of the context 10: part of the argument to a dependent context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.TrmTag" href="#Gatlab.Syntax.Theories.TrmTag"><code>Gatlab.Syntax.Theories.TrmTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is used as a supertype for the tag types in a theory that correspond to term constructors.</p><p>Example:</p><pre><code class="language-julia hljs">module Category
struct compose &lt;: TrmTag{3} end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L136-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.Typ" href="#Gatlab.Syntax.Theories.Typ"><code>Gatlab.Syntax.Theories.Typ</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The head of a type can never come from a context, only a theory, because it  should point at a type constructor judgment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L56-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.TypTag" href="#Gatlab.Syntax.Theories.TypTag"><code>Gatlab.Syntax.Theories.TypTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This is used as a supertype for the tag types in a theory that correspond to type constructors.</p><p>Example:</p><pre><code class="language-julia hljs">module Category
struct Ob &lt;: TypTag{1} end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L107-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.gettheory" href="#Gatlab.Syntax.Theories.gettheory"><code>Gatlab.Syntax.Theories.gettheory</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Meant to be overloaded as</p><pre><code class="language-julia hljs">gettheory(::T) = ...</code></pre><p>where <code>T</code> is a singleton struct subtyping <code>AbstractTheory</code></p><p>Returns the @ref(Theory) associated to <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L222-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.gettheory-Tuple{Type{&lt;:AbstractTheory}}" href="#Gatlab.Syntax.Theories.gettheory-Tuple{Type{&lt;:AbstractTheory}}"><code>Gatlab.Syntax.Theories.gettheory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A convenience overload of <code>theory</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L235-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Theories.lookup-Tuple{FullContext, Name}" href="#Gatlab.Syntax.Theories.lookup-Tuple{FullContext, Name}"><code>Gatlab.Syntax.Theories.lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the <code>Lvl</code> corresponding to a Name. This is the most recent judgment with that name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Theories.jl#L191-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Context}" href="#Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Context}"><code>Gatlab.Syntax.TheoryMaps.TheoryMap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Map a context in the domain theory into a context of the codomain theory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/TheoryMaps.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Gatlab.Syntax.Theories.TrmTyp}" href="#Gatlab.Syntax.TheoryMaps.TheoryMap-Tuple{Gatlab.Syntax.Theories.TrmTyp}"><code>Gatlab.Syntax.TheoryMaps.TheoryMap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Suppose dom(f) is [X,Y,Z,P,Q] and codom(f) is [XX,ϕ,ψ] suppose we have a term: P(a,Q(b,c)) ⊢ a::X,b::Y,c::Z i.e. 4({1},5({2},{3}))</p><p>f maps all sorts to XX f maps {P(x,y) ⊢ x::X,y::Y} to ϕ(ψ(y),x) i.e. 2(3({2}),{1}) and {Q(u,w) ⊢ u::Y,w::Z}    to ψ(w)      i.e. 3({2})</p><p>We should our term translate first to ϕ(ψ(y),x)  i.e.  2(3({2}),{1})</p><p>and then substitute x (i.e. {1}) for the mapped first argument  y (i.e. 5) for f(q(b,c)) i.e. ϕ(ψ(ψ(c)),x) 2(3(3({3})),{1})</p><p>So f(4({1},5({2},{3}))) = 2(3(3({3})),{1})</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/TheoryMaps.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Pushouts.pushout-Tuple{Name, TheoryIncl, TheoryIncl}" href="#Gatlab.Syntax.Pushouts.pushout-Tuple{Name, TheoryIncl, TheoryIncl}"><code>Gatlab.Syntax.Pushouts.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout two inclusions.      f   A ↪ B  g ↓   ↓   C-&gt;⌜D</p><p>D is a copy of B with the novel judgments of C added aftewards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Pushouts.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Pushouts.substitute_level-Tuple{Judgment, Vector{Int64}}" href="#Gatlab.Syntax.Pushouts.substitute_level-Tuple{Judgment, Vector{Int64}}"><code>Gatlab.Syntax.Pushouts.substitute_level</code></a> — <span class="docstring-category">Method</span></header><section><div><p>v is a FinFunction from old de bruijn levels to new ones. Its domain is the  size of the theory of the judgment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Pushouts.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Visualization.Sequent" href="#Gatlab.Syntax.Visualization.Sequent"><code>Gatlab.Syntax.Visualization.Sequent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Intermediate representation of a judgment for pretty printing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Visualization.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Visualization.ctx_dict-Tuple{Context, Theory, Any}" href="#Gatlab.Syntax.Visualization.ctx_dict-Tuple{Context, Theory, Any}"><code>Gatlab.Syntax.Visualization.ctx_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the strings required to print the a context t1 that extends t2. E.g. [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]=&gt;&quot;Ob&quot;, [&quot;f&quot;,&quot;g&quot;]=&gt;[&quot;Hom(a,b)&quot;], ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Visualization.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Trm, Int64}" href="#Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Trm, Int64}"><code>Gatlab.Syntax.Visualization.show_inctx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show a debruijn level term in a theory + context i marks where the theory effectively ends (indices higher than this  refer to the context).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Visualization.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Typ, Int64}" href="#Gatlab.Syntax.Visualization.show_inctx-Tuple{Theory, Context, Typ, Int64}"><code>Gatlab.Syntax.Visualization.show_inctx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show a debruijn level type in a theory + context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/syntax/Visualization.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Logic.EGraphs.context-Tuple{EGraph, ETrm}" href="#Gatlab.Logic.EGraphs.context-Tuple{EGraph, ETrm}"><code>Gatlab.Logic.EGraphs.context</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This computes the inferred context for an etrm.</p><p>For example, if <code>f</code> is an id with etyp <code>Hom(x,y)</code> and <code>g</code> is an id with etyp <code>Hom(y,z)</code>, then context(eg, :(g ∘ f)) computes the context <code>[x,y,z,f,g]</code>.</p><p>The tricky thing comes from term formers like</p><p>weaken(x)::Term(n) ⊣ [n::Nat, x::Term(S(n))]</p><p>We get the ETyp for x from the e-graph, and then we have to ematch its argument with <code>S(n)</code> to figure out what <code>n</code> is... The problem is that in general <code>S</code> will not be injective, so this is ambiguous!</p><p>What we are going to do for now is say that types in the context of a term former can&#39;t be nested. I.e., we only allow types of the form <code>Term(n)</code>, not <code>Term(S(n))</code>.</p><p>Fortunately, I don&#39;t think we care about any theories with this kind of context former.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/logic/EGraphs.jl#L61-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Models.ModelInterface.Model" href="#Gatlab.Models.ModelInterface.Model"><code>Gatlab.Models.ModelInterface.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Julia value with type <code>Model{T, Tuple{Ts...}}</code> represents a model of the theory <code>T</code> that has the types <code>Ts...</code> assigned to the type constructors in <code>T</code>.</p><p>Note that we do not expect that structs subtyping <code>Model</code> will necessarily be singletons. In general, they may contain runtime data which is used in the implementations of the various methods. For instance, this would be the case for a slice category: the <code>Model</code> corresponding to a slice category would have runtime data of the object that we are slicing over.</p><p>An instance of <code>Model{T, Tuple{Ts...}}</code> should have overloads for</p><ul><li><code>checkvalidity</code></li><li><code>ap</code></li></ul><p>as described in the docstrings for each of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/models/ModelInterface.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Models.ModelInterface.ap" href="#Gatlab.Models.ModelInterface.ap"><code>Gatlab.Models.ModelInterface.ap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Meant to be overloaded as</p><pre><code class="language-julia hljs">ap(m::Model{T}, ::TrmTag{i}, args...; context_args...)</code></pre><p>where:</p><ul><li><code>i</code> is the level of a term constructor in <code>T</code></li><li><code>args</code> consists of, for each argument to the term constructor <code>i</code>, a valid value</li></ul><p>of the relevant type</p><ul><li><code>context_args</code> consists of keyword arguments for each of the elements of</li></ul><p>the context that are not mentioned in <code>args</code>. Sometimes these are needed for implementation, sometimes they are not, so it is possible to call <code>ap</code> without instantiating all of these and hoping for the best.</p><p>Returns the result of applying the term constructor to the arguments, according to the model <code>m</code>. For instance, this is used to compose morphisms, or to get the identity morphism at an object.</p><p>Note that we assume in <code>ap</code> that the arguments have already been checked, using <code>checkvalidity</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/models/ModelInterface.jl#L52-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Models.ModelInterface.checkvalidity" href="#Gatlab.Models.ModelInterface.checkvalidity"><code>Gatlab.Models.ModelInterface.checkvalidity</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Meant to be overloaded as</p><pre><code class="language-julia hljs">checkvalidity(m::Model{T}, ::TypTag{i}, args..., x) where {T &lt;: AbstractTheory} = ...</code></pre><p>where:</p><ul><li><code>i</code> is the level of a type constructor in <code>T</code></li><li><code>args</code> are the pre-checked type arguments to the type constructor</li><li><code>x</code> is the value to be checked</li></ul><p>Returns a boolean which is true if <code>x</code> is a valid element of the type <code>i</code> with type arguments <code>args...</code> according to <code>Model</code> and false otherwise.</p><p>A basic implementation of <code>checkvalidity</code> might simply use dispatching on the type to return true. But in general, it might be necessary to verify runtime data, for instance checking that something is sorted or something is injective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/models/ModelInterface.jl#L26-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Models.ModelInterface.checkvalidity-Tuple{Model, TypTag, Vararg{Any}}" href="#Gatlab.Models.ModelInterface.checkvalidity-Tuple{Model, TypTag, Vararg{Any}}"><code>Gatlab.Models.ModelInterface.checkvalidity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If not otherwise specified, we assume that a given value is not valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/models/ModelInterface.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gatlab.Dsl" href="#Gatlab.Dsl"><code>Gatlab.Dsl</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A module for various features of Gatlab packaged as domain specific languages</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/Gatlab.jl/blob/ab53bda1613285a784b8b86d3d40e0c19c54a991/src/dsl/module.jl#L1-L3">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/models/">« Model families</a><a class="docs-footer-nextpage" href="../stdlib/">Standard Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 01:02">Thursday 1 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
