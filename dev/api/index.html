<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GATlab.jl</title><meta name="title" content="Library Reference · GATlab.jl"/><meta property="og:title" content="Library Reference · GATlab.jl"/><meta property="twitter:title" content="Library Reference · GATlab.jl"/><meta name="description" content="Documentation for GATlab.jl."/><meta property="og:description" content="Documentation for GATlab.jl."/><meta property="twitter:description" content="Documentation for GATlab.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GATlab.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GATlab.jl</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../concepts/overview/">For Catlab users</a></li><li><a class="tocitem" href="../concepts/theories/">Theories</a></li><li><a class="tocitem" href="../concepts/models/">Model families</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../stdlib/">Standard Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Binding" href="#GATlab.Syntax.Scopes.Binding"><code>GATlab.Syntax.Scopes.Binding</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Binding{T, Sig}</code></p><p>A binding associates some <code>T</code>-typed value to a name and possibly some aliases, disambiguated by a signature in <code>Sig</code> in the case of overloading.</p><p><code>primary</code> is an optional distinguished element of aliases <code>value</code> is the element <code>sig</code> is a way of uniquely distinguishing this element from others with the same name  (for example, ⊗ : Ob x Ob -&gt; Ob and Hom x Hom -&gt; Hom)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Context" href="#GATlab.Syntax.Scopes.Context"><code>GATlab.Syntax.Scopes.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Context</code> is anything which contains an ordered list of scopes.</p><p>Scopes within a context are referred to by <em>level</em>, which is their index within this list.</p><p><code>Context</code>s should overload:</p><ul><li><code>getscope(c::Context, level::Int) -&gt; Scope</code></li><li><code>nscopes(c::Context) -&gt; Int</code></li><li><code>hastag(c::Context, tag::ScopeTag) -&gt; Bool</code></li><li><code>hasname(c::Context, name::Symbol) -&gt; Bool</code></li><li><code>getlevel(c::Context, tag::ScopeTag) -&gt; Int</code></li><li><code>getlevel(c::Context, name::Symbol) -&gt; Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L252-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScope" href="#GATlab.Syntax.Scopes.HasScope"><code>GATlab.Syntax.Scopes.HasScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstract type for wrappers around a single scope.</p><p>Must overload</p><p><code>getscope(hs::HasScope) -&gt; Scope</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.HasScopeList" href="#GATlab.Syntax.Scopes.HasScopeList"><code>GATlab.Syntax.Scopes.HasScopeList</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A type for things which contain a scope list.</p><p>Notably, GATs contain a scope list.</p><p>Must implement:</p><p><code>getscopelist(hsl::HasScopeList) -&gt; ScopeList</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L698-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Ident" href="#GATlab.Syntax.Scopes.Ident"><code>GATlab.Syntax.Scopes.Ident</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Ident</code></p><p>An identifier.</p><p><code>tag</code> refers to the scope that this Ident is bound in <code>lid</code> indexes the scope that Ident is bound in <code>name</code> is an optional field for the sake of printing. A variable in a scope might be associated with several names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L114-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.LID" href="#GATlab.Syntax.Scopes.LID"><code>GATlab.Syntax.Scopes.LID</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A LID (Local ID) indexes a given scope.</p><p>Currently, scopes assign LIDs sequentially – this is not a stable guarantee however, and in theory scopes could have &quot;sparse&quot; LIDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.Scope" href="#GATlab.Syntax.Scopes.Scope"><code>GATlab.Syntax.Scopes.Scope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Scope{T, Sig}</code></p><p>In GATlab, we handle overloading and shadowing with a notion of <em>scope</em>. Anything which binds variables introduces a scope, for instance a <code>@theory</code> declaration or a context. For example, a scope with 3 elements:</p><pre><code class="nohighlight hljs">x::Int = 3
y::String = &quot;hello&quot;
x::String = &quot;ex&quot;</code></pre><p>This is a valid scope even though there are name collisions, because the signature (in this case, a datatype) disambiguates. Of course, it may not be wise to disambiguate by type, because it is not always possible to infer expected type.  In general, one should pick something that can be inferred, and <code>Nothing</code> is always a reasonable choice, which disallows any name collisions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L323-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTag" href="#GATlab.Syntax.Scopes.ScopeTag"><code>GATlab.Syntax.Scopes.ScopeTag</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The tag that makes reference to a specific scope possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ScopeTagError" href="#GATlab.Syntax.Scopes.ScopeTagError"><code>GATlab.Syntax.Scopes.ScopeTagError</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ScopeTagError</code></p><p>An error to throw when an identifier has an unexpected scope tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{ScopeTag, ScopeTag}" href="#Base.:+-Tuple{ScopeTag, ScopeTag}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deterministically combine two scope tags into a third</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.equiv-Tuple{Scope, Scope}" href="#GATlab.Syntax.Scopes.equiv-Tuple{Scope, Scope}"><code>GATlab.Syntax.Scopes.equiv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compare two scopes, ignoring the difference in the top-level scope tag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.getlid-Union{Tuple{Sig}, Tuple{T}, Tuple{HasScope{T, Sig}, Symbol}} where {T, Sig}" href="#GATlab.Syntax.Scopes.getlid-Union{Tuple{Sig}, Tuple{T}, Tuple{HasScope{T, Sig}, Symbol}} where {T, Sig}"><code>GATlab.Syntax.Scopes.getlid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the level of a binding given the name and possibly the signature</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L464-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.hasident-Tuple{Context}" href="#GATlab.Syntax.Scopes.hasident-Tuple{Context}"><code>GATlab.Syntax.Scopes.hasident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hasident</code> checks whether an identifier with specified data exists, by attempting to create it and returning whether or not that attempt failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L662-L665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.ident-Tuple{Context}" href="#GATlab.Syntax.Scopes.ident-Tuple{Context}"><code>GATlab.Syntax.Scopes.ident</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ident</code> creates an <code>Ident</code> from a context and some partial data supplied as keywords.</p><p>Keywords arguments:</p><ul><li><code>tag::Union{ScopeTag, Nothing}</code>. The tag of the scope that the <code>Ident</code> is in.</li><li><code>name::Union{Symbol, Nothing}</code>. The name of the identifier.</li><li><code>lid::Union{LID, Nothing}</code>. The lid of the identifier within its scope.</li><li><code>level::Union{Int, Nothing}</code>. The level of the scope within the context.</li><li><code>sig::Any</code>. The signature of the identifier, to disambiguate between multiple identifiers with the same name within the same scope.</li><li><code>strict::Bool</code>. If <code>strict</code> is true, throw an error if not found, else return nothing.</li><li><code>isunique::Bool</code>. If <code>isunique</code> is true, then don&#39;t use the signature to disambiguate, instead fail if their are multiple identifiers with the same name in a scope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L614-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}" href="#GATlab.Syntax.Scopes.rename-Tuple{ScopeTag, Dict{Symbol, Symbol}, Any}"><code>GATlab.Syntax.Scopes.rename</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>rename(tag::ScopeTag, replacements::Dict{Symbol, Symbol}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, and change any name <code>n</code> in scope <code>tag</code> to <code>get(replacements, n, n)</code>. Overload this function on structs that have names in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}" href="#GATlab.Syntax.Scopes.retag-Tuple{Dict{ScopeTag, ScopeTag}, Any}"><code>GATlab.Syntax.Scopes.retag</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>retag(replacements::Dict{ScopeTag, ScopeTag}, x::T) where {T} -&gt; T</code></p><p>Recurse through the structure of <code>x</code>, swapping any instance of a ScopeTag <code>t</code> with <code>get(replacements, t, t)</code>. Overload this function on structs that have ScopeTags within them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Scopes.unsafe_addalias!-Tuple{Scope, Symbol, Symbol}" href="#GATlab.Syntax.Scopes.unsafe_addalias!-Tuple{Scope, Symbol, Symbol}"><code>GATlab.Syntax.Scopes.unsafe_addalias!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>unsafe_addalias!</code> should only be used when <code>unsafe_pushbinding!</code> won&#39;t be called again, because new bindings won&#39;t get the old aliases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Scopes.jl#L440-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Judgment" href="#GATlab.Syntax.GATs.Judgment"><code>GATlab.Syntax.GATs.Judgment</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Judgment</code></p><p>A judgment is either a type constructor, term constructor, or axiom; a GAT is composed of a list of judgments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AbstractConstant" href="#GATlab.Syntax.GATs.AbstractConstant"><code>GATlab.Syntax.GATs.AbstractConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We need this to resolve a mutual reference loop; the only subtype is Constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgAxiom" href="#GATlab.Syntax.GATs.AlgAxiom"><code>GATlab.Syntax.GATs.AlgAxiom</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgAxiom</code></p><p>A declaration of an axiom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSort" href="#GATlab.Syntax.GATs.AlgSort"><code>GATlab.Syntax.GATs.AlgSort</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSort</code></p><p>A <em>sort</em>, which is essentially a type constructor without arguments <code>ref</code> must be reference to a <code>AlgTypeConstructor</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgSorts" href="#GATlab.Syntax.GATs.AlgSorts"><code>GATlab.Syntax.GATs.AlgSorts</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgSorts</code></p><p>A description of the argument sorts for a term constructor, used to disambiguate multiple term constructors of the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTerm" href="#GATlab.Syntax.GATs.AlgTerm"><code>GATlab.Syntax.GATs.AlgTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTerm</code></p><p>One syntax tree to rule all the terms. Head can be a reference to an AlgTermConstructor, to a Binding{AlgType, Nothing}, or simply an AbstractConstant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTermConstructor" href="#GATlab.Syntax.GATs.AlgTermConstructor"><code>GATlab.Syntax.GATs.AlgTermConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTermConstructor</code></p><p>A declaration of a term constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgType" href="#GATlab.Syntax.GATs.AlgType"><code>GATlab.Syntax.GATs.AlgType</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgType</code></p><p>One syntax tree to rule all the types. <code>head</code> must be reference to a <code>AlgTypeConstructor</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.AlgTypeConstructor" href="#GATlab.Syntax.GATs.AlgTypeConstructor"><code>GATlab.Syntax.GATs.AlgTypeConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AlgTypeConstructor</code></p><p>A declaration of a type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.Constant" href="#GATlab.Syntax.GATs.Constant"><code>GATlab.Syntax.GATs.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Constant</code></p><p>A Julia value in an algebraic context. Checked elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GAT" href="#GATlab.Syntax.GATs.GAT"><code>GATlab.Syntax.GATs.GAT</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GAT</code></p><p>A generalized algebraic theory. Essentially, just consists of a name and a list of <code>GATSegment</code>s, but there is also some caching to make access faster. Specifically, there is a dictionary to map ScopeTag to position in the list of segments, and there are lists of all of the identifiers for term constructors, type constructors, and axioms so that they can be iterated through faster.</p><p>GATs allow overloading but not shadowing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L321-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.GATSegment" href="#GATlab.Syntax.GATs.GATSegment"><code>GATlab.Syntax.GATs.GATSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>GATSegment</code></p><p>A piece of a GAT, consisting of a scope that binds judgments to names, possibly disambiguated by argument sorts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.JudgmentBinding" href="#GATlab.Syntax.GATs.JudgmentBinding"><code>GATlab.Syntax.GATs.JudgmentBinding</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>JudgmentBinding</code></p><p>A binding of a judgment to a name and possibly a signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.SortScope" href="#GATlab.Syntax.GATs.SortScope"><code>GATlab.Syntax.GATs.SortScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SortScope</code></p><p>A scope where variables are assigned to <code>AlgSorts</code>s, and no overloading is permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.TermInCtx" href="#GATlab.Syntax.GATs.TermInCtx"><code>GATlab.Syntax.GATs.TermInCtx</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with an accompanying type scope, e.g.</p><p><strong>(a,b)::R</strong></p><p>a*(a+b)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.TermInCtx-Tuple{GAT, Ident}" href="#GATlab.Syntax.GATs.TermInCtx-Tuple{GAT, Ident}"><code>GATlab.Syntax.GATs.TermInCtx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the canonical term associated with a term constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.TypeScope" href="#GATlab.Syntax.GATs.TypeScope"><code>GATlab.Syntax.GATs.TypeScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>TypeScope</code></p><p>A scope where variables are assigned to <code>AlgType</code>s, and no overloading is permitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgTerm}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgTerm}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Some expr may have already been bound (e.g. by an explicit context) and thus  oughtn&#39;t be interpreted as <code>default</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgType}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{AlgType}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Some expr may have already been bound (e.g. by an explicit context) and thus  oughtn&#39;t be interpreted as <code>default</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Binding{AlgType, Nothing}}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Binding{AlgType, Nothing}}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return <code>nothing</code> if the binding we parse has already been bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L651-L653">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.argcontext-Tuple{Union{AlgTermConstructor, AlgTypeConstructor}}" href="#GATlab.Syntax.GATs.argcontext-Tuple{Union{AlgTermConstructor, AlgTypeConstructor}}"><code>GATlab.Syntax.GATs.argcontext</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local context of an AlgTermConstructor, including the arguments themselves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.bind_localctx-Tuple{GAT, TermInCtx}" href="#GATlab.Syntax.GATs.bind_localctx-Tuple{GAT, TermInCtx}"><code>GATlab.Syntax.GATs.bind_localctx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take a term constructor and determine terms of its local context.</p><p>This function is mutually recursive with <code>infer_type</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L558-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}" href="#GATlab.Syntax.GATs.equations-Tuple{GAT, Ident}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get equations for a term or type constructor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.equations-Tuple{Scope{AlgType, Nothing}, Scope{AlgType, Nothing}, GAT}" href="#GATlab.Syntax.GATs.equations-Tuple{Scope{AlgType, Nothing}, Scope{AlgType, Nothing}, GAT}"><code>GATlab.Syntax.GATs.equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implicit equations defined by a context.</p><p>This function allows a generalized algebraic theory (GAT) to be expressed as an essentially algebraic theory, i.e., as partial functions whose domains are defined by equations.</p><p>References:</p><ul><li>(Cartmell, 1986, Sec 6: &quot;Essentially algebraic theories and categories with  finite limits&quot;)</li><li>(Freyd, 1972, &quot;Aspects of topoi&quot;)</li></ul><p>This function gives expressions for computing each of the elements of <code>context</code>   from the <code>args</code>, as well as checking that the args are well-typed.</p><p>Example:</p><blockquote><p>equations({f::Hom(a,b), g::Hom(b,c)}, {a::Ob, b::Ob, c::Ob}, ThCategory)</p></blockquote><p>ways<em>of</em>computing = Dict(a =&gt; [dom(f)], b =&gt; [codom(f), dom(g)], c =&gt; [codom(g)],                             f =&gt; [f], g =&gt; [g])</p><p>Algorithm:</p><p>Start from the arguments. We know how to compute each of the arguments; they are given. Each argument tells us how to compute other arguments, and also elements of the context</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L421-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.infer_type-Tuple{GAT, TermInCtx}" href="#GATlab.Syntax.GATs.infer_type-Tuple{GAT, TermInCtx}"><code>GATlab.Syntax.GATs.infer_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Infer the type of the term of a term. If it is not in context, recurse on its  arguments. The term constructor&#39;s output type yields the resulting type once its localcontext variables are substituted with the relevant AlgTerms. </p><pre><code class="nohighlight hljs">          (x,y,z)::Ob, p::Hom(x,y), q::Hom(y,z)</code></pre><p>E.g. given    –––––––––––––––––––                            id(x)⋅(p⋅q)</p><pre><code class="nohighlight hljs">             (a,b,c)::Ob, f::Hom(a,b), g::Hom(b,c)</code></pre><p>and output type:  ––––––––––––––––––                               Hom(a,c)</p><p>We first recursively find <code>{id(x) =&gt; Hom(x,x), p⋅q =&gt; Hom(x,z)}</code>. We ultimately  want an AlgTerm for everything in the output type&#39;s context such that we can  substitute into <code>Hom(a,c)</code> to get the final answer. It will help to also compute  the AlgType for everything in the context. We work backwards, since we start by knowing <code>{f =&gt; id(x)::Hom(x,x), g=&gt; p⋅q :: Hom(x,z)}</code>. For <code>a</code> <code>b</code> and <code>c</code>,  we use <code>equations</code> which tell us, e.g., that <code>a = dom(f)</code>. So we can grab the  first argument of the <em>type</em> of <code>f</code> (i.e. grab <code>x</code> from <code>Hom(x,x)</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L510-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.normalize_decl-Tuple{Any}" href="#GATlab.Syntax.GATs.normalize_decl-Tuple{Any}"><code>GATlab.Syntax.GATs.normalize_decl</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>axiom=true</code> adds a <code>::default</code> to exprs like <code>f(a,b) ⊣ [a::A, b::B]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L692-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.parsetypescope-Tuple{Context, AbstractVector}" href="#GATlab.Syntax.GATs.parsetypescope-Tuple{Context, AbstractVector}"><code>GATlab.Syntax.GATs.parsetypescope</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Keep track of variables already bound (e.g. in local context) so that they need not be redefined, e.g. <code>compose(f,g::Hom(b,c)) ⊣ [(a,b,c)::Ob, f::Hom(a,b)]</code> (If <code>f</code> were not defined in the local context, it would be parsed as <code>default</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L662-L666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgTerm}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgTerm)</code></p><p>Throw an error if a the head of an AlgTerm (which refers to a term constructor) has arguments of the wrong sort. Returns the sort of the term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}" href="#GATlab.Syntax.GATs.sortcheck-Tuple{Context, AlgType}"><code>GATlab.Syntax.GATs.sortcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sortcheck(ctx::Context, t::AlgType)</code></p><p>Throw an error if a the head of an AlgType (which refers to a type constructor) has arguments of the wrong sort.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.GATs.substitute_term-Tuple{GATlab.Syntax.GATs.TrmTyp, Dict{Ident, AlgTerm}}" href="#GATlab.Syntax.GATs.substitute_term-Tuple{GATlab.Syntax.GATs.TrmTyp, Dict{Ident, AlgTerm}}"><code>GATlab.Syntax.GATs.substitute_term</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace idents with AlgTerms. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/GATs.jl#L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.Presentations.Presentation" href="#GATlab.Syntax.Presentations.Presentation"><code>GATlab.Syntax.Presentations.Presentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A presentation has a set of generators, given by a <code>TypeScope</code>, and a set of  equations among terms which can refer to those generators. Each element of  <code>eqs</code> is a list of terms which are asserted to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Presentations.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Presentation}}" href="#GATlab.Syntax.ExprInterop.fromexpr-Tuple{Context, Any, Type{Presentation}}"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse, e.g.:</p><pre><code class="nohighlight hljs">(a,b,c)::Ob
f::Hom(a, b)
g::Hom(b, c)
h::Hom(a, c)
h′::Hom(a, c)
compose(f, g) == h == h′</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Presentations.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr-Tuple{Presentation}" href="#GATlab.Syntax.ExprInterop.toexpr-Tuple{Presentation}"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Context of presentation is the underlying GAT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/Presentations.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.fromexpr" href="#GATlab.Syntax.ExprInterop.fromexpr"><code>GATlab.Syntax.ExprInterop.fromexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>fromexpr(c::Context, e::Any, T::Type) -&gt; Union{T,Nothing}</code></p><p>Converts a Julia Expr into type T, in a certain scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/ExprInterop.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.ExprInterop.toexpr" href="#GATlab.Syntax.ExprInterop.toexpr"><code>GATlab.Syntax.ExprInterop.toexpr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>toexpr(c::Context, t) -&gt; Any</code></p><p>Converts GATlab syntax into an Expr that can be read in via <code>fromexpr</code> to get the same thing. Crucially, the output of this will depend on the order of the scopes in <code>c</code>, and if read back in with a different <code>c</code> may end up with different results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/ExprInterop.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP" href="#GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP"><code>GATlab.Syntax.TheoryInterface.GAT_MODULE_LOOKUP</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>When we declare a new theory, we add the scope tag of its new segment to this dictionary pointing to the module corresponding to the new theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/syntax/TheoryInterface.jl#L36-L39">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.ImplementationNotes" href="#GATlab.Models.ModelInterface.ImplementationNotes"><code>GATlab.Models.ModelInterface.ImplementationNotes</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ImplementationNotes</code></p><p>Information about how a model implements a <code>GATSegment</code>. Right now, just the docstring attached to the <code>@instance</code> macro, but could contain more info in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag" href="#GATlab.Models.ModelInterface.implements-Union{Tuple{tag}, Tuple{Module, Type{Val{tag}}}} where tag"><code>GATlab.Models.ModelInterface.implements</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>implements(m::Model, tag::ScopeTag) -&gt; Union{ImplementationNotes, Nothing}</code></p><p>If <code>m</code> implements the GATSegment referred to by <code>tag</code>, then return the corresponding implementation notes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr}" href="#GATlab.Models.ModelInterface.parse_instance_body-Tuple{Expr}"><code>GATlab.Models.ModelInterface.parse_instance_body</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parses the raw julia expression into JuliaFunctions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L202-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}" href="#GATlab.Models.ModelInterface.qualify_function-Tuple{JuliaFunction, Any, Union{Nothing, Expr, Symbol}, Any}"><code>GATlab.Models.ModelInterface.qualify_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add <code>model</code> kwarg (it shouldn&#39;t have it already) Qualify method name to be in theory module Add <code>context</code> kwargs if not already present</p><p>TODO: throw error if there&#39;s junk kwargs present already?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L436-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}" href="#GATlab.Models.ModelInterface.typecheck_instance-Tuple{GAT, Vector{JuliaFunction}, Vector{Symbol}, Dict{AlgSort}}"><code>GATlab.Models.ModelInterface.typecheck_instance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Throw error if missing a term constructor. Provides default instances for type constructors and type arguments, which return true or error, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L311-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}" href="#GATlab.Models.ModelInterface.@instance-Tuple{Any, Any, Any}"><code>GATlab.Models.ModelInterface.@instance</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Usage:</p><pre><code class="language-julia hljs">struct TypedFinSetC &lt;: Model{Tuple{Vector{Int}, Vector{Int}}}
  ntypes::Int
end

@instance ThCategory{Vector{Int}, Vector{Int}} [model::TypedFinSetC] begin
  Ob(v::Vector{Int}) = all(1 &lt;= j &lt;= model.ntypes for j in v)
  Hom(f::Vector{Int}, v::Vector{Int}, w::Vector{Int}) =
     length(f) == length(v) &amp;&amp; all(1 &lt;= y &lt;= length(w) for y in f)

  id(v::Vector{Int}) = collect(eachindex(v))
  compose(f::Vector{Int}, g::Vector{Int}) = g[f]

  dom(f::Vector{Int}; context) = context.dom
  codom(f::Vector{Int}; context) = context.codom
end

struct SliceCat{Ob, Hom, C &lt;: Model{Tuple{Ob, Hom}}} &lt;: Model{Tuple{Tuple{Ob, Hom}, Hom}}
  c::C
end

@instance ThCategory{Tuple{Ob, Hom}, Hom} [model::SliceCat{Ob, Hom, C}] where {Ob, Hom, C&lt;:Model{Tuple{Ob, Hom}}} begin
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/ModelInterface.jl#L104-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.GATExpr" href="#GATlab.Models.SymbolicModels.GATExpr"><code>GATlab.Models.SymbolicModels.GATExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base type for expressions in the syntax of a GAT. This is an alternative to <code>AlgTerm</code> used for backwards compatibility with Catlab.</p><p>We define Julia types for each <em>type constructor</em> in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia&#39;s type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)</p><p>The concrete types are structurally similar to the core type <code>Expr</code> in Julia. However, the <em>term constructor</em> is represented as a type parameter, rather than as a <code>head</code> field. This makes dispatch using Julia&#39;s type system more convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.nameof-Tuple{GATExpr{:generator}}" href="#Base.nameof-Tuple{GATExpr{:generator}}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get name of GAT generator expression as a <code>Symbol</code>.</p><p>If the generator has no name, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.constructor_name-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.constructor_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Name of constructor that created expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L483-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}" href="#GATlab.Models.SymbolicModels.functor-Tuple{Tuple, GATExpr}"><code>GATlab.Models.SymbolicModels.functor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Functor from GAT expression to GAT instance.</p><p>Strictly speaking, we should call these &quot;structure-preserving functors&quot; or, better, &quot;model homomorphisms of GATs&quot;. But this is a category theory library, so we&#39;ll go with the simpler &quot;functor&quot;.</p><p>A functor is completely determined by its action on the generators. There are several ways to specify this mapping:</p><ol><li><p>Specify a Julia instance type for each GAT type, using the required <code>types</code> tuple. For this to work, the generator constructors must be defined for the instance types.</p></li><li><p>Explicitly map each generator term to an instance value, using the <code>generators</code> dictionary.</p></li><li><p>For each GAT type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the <code>terms</code> dictionary.</p></li></ol><p>The <code>terms</code> dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.</p><p>FIXME</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L496-L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}" href="#GATlab.Models.SymbolicModels.parse_json_sexpr-Tuple{Module, Any}"><code>GATlab.Models.SymbolicModels.parse_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Deserialize expression from JSON-able S-expression.</p><p>If <code>symbols</code> is true (the default), strings are converted to symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L569-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_latex-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_latex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using LaTeX math.</p><p>Does <em>not</em> include <code>$</code> or <code>\[begin|end]{equation}</code> delimiters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L649-L653">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the syntax expression as an S-expression.</p><p>Cf. the standard library function <code>Meta.show_sexpr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L607-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.show_unicode-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.show_unicode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Show the expression in infix notation using Unicode symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L624-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}" href="#GATlab.Models.SymbolicModels.symbolic_instance_methods-Tuple{GAT, Any, Symbol, Dict{Ident, JuliaFunction}}"><code>GATlab.Models.SymbolicModels.symbolic_instance_methods</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Julia function for every type constructor, accessor, and term constructor. Term constructors can be overwritten by <code>overrides</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L385-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.syntax_module-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.syntax_module</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get syntax module of given expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L488-L490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}" href="#GATlab.Models.SymbolicModels.to_json_sexpr-Tuple{GATExpr}"><code>GATlab.Models.SymbolicModels.to_json_sexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Serialize expression as JSON-able S-expression.</p><p>The format is an S-expression encoded as JSON, e.g., &quot;compose(f,g)&quot; is represented as [&quot;compose&quot;, f, g].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}" href="#GATlab.Models.SymbolicModels.@symbolic_model-Tuple{Any, Any, Any}"><code>GATlab.Models.SymbolicModels.@symbolic_model</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@symbolic_model generates the free model of a theory, generated by symbols.</p><p>This is backwards compatible with the @syntax macro in Catlab.</p><p>One way of thinking about this is that for every type constructor, we add an additional term constructor that builds a &quot;symbolic&quot; element of that type from any Julia value. This term constructor is called &quot;generator&quot;.</p><p>An invocation of <code>@symbolic_model</code> creates the following.</p><ol><li>A module with a struct for each type constructor, which has a single type</li></ol><p>parameter <code>T</code> and two fields, <code>args</code> and <code>type_args</code>. Instances of this struct are thought of as elements of the type given by the type constructor applied to <code>type_args</code>. The type parameter refers to the term constructor that was used to generate the element, including the special term constructor <code>:generator</code>, which has as its single argument an <code>Any</code>.</p><p>For instance, in the theory of categories, we might have the following elements.</p><pre><code class="nohighlight hljs">using .FreeCategory
x = Ob{:generator}([:x], [])
y = Ob{:generator}([:y], [])
f = Hom{:generator}([:f], [x, y])
g = Hom{:generator}([:g], [y, x])
h = Hom{:compose}([f, g], [x, x])</code></pre><ol><li>Methods inside the module (not exported) for all of the term constructors and</li></ol><p>field accessors (i.e. stuff like <code>compose, id, dom, codom</code>), which construct terms.</p><ol><li>A default instance (i.e., without a model parameter) of the theory using the</li></ol><p>types in this generated model. Methods in this instance can be overridden by the body of <code>@symbolic_model</code> to perform rewriting for the sake of normalization, for instance flattening associative and unital operations.</p><ol><li>Coercion methods of the type constructors that allow one to introduce generators.</li></ol><pre><code class="nohighlight hljs">x = ThCategory.Ob(FreeCategory.Ob, :x)
y = ThCategory.Ob(FreeCategory.Ob, :y)
f = ThCategory.Hom(:f, x, y)</code></pre><p>Note that in both the instance and in these coercion methods, we must give the expected type as the first argument when it cannot be infered by the other arguments. For instance, instead of</p><pre><code class="nohighlight hljs">munit() = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">munit(::Type{FreeSMC.Ob}) = ...</code></pre><p>and likewise instead of</p><pre><code class="nohighlight hljs">ThCategory.Ob(x::Any) = ...</code></pre><p>we have</p><pre><code class="nohighlight hljs">ThCategory.Ob(::Type{FreeCategory.Ob}, x::Any) = ...</code></pre><p>Example:</p><pre><code class="language-julia hljs">@symbolic_model FreeCategory{ObExr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate_unit(new(f,g; strict=true), id)
end</code></pre><p>This generates:</p><pre><code class="language-julia hljs">module FreeCategory
export Ob, Hom
using ..__module__

const THEORY_MODULE = ThCategory

struct Ob{T} &lt;: __module__.ObExpr{T} # T is :generator or a Symbol
  args::Vector
  type_args::Vector{GATExpr}
end

struct Hom{T} &lt;: __module__.HomExpr{T}
  args::Vector
  type_args::Vector{GATExpr}
end

dom(x::Hom) = x.type_args[1]

codom(x::Hom) = x.type_args[2]

function compose(f::Hom, g::Hom; strict=true)
  if strict &amp;&amp; !(codom(f) == dom(g))
    throw(SyntaxDomainError(:compose, [f, g]))
  end
  Hom{:compose}([f, g], [dom(f), codom(g)])
end

function id(x::Ob)
  Ob{:id}([x], [x, x])
end
end

# default implementations 

function ThCategory.dom(x::FreeCategory.Hom)::FreeCategory.Ob
  FreeCategory.dom(x)
end

function ThCategory.Ob(::Type{FreeCategory.Ob}, __value__::Any)::FreeCategory.Ob
  FreeCategory.Ob{:generator}([__value__], [])
end

function ThCategory.id(A::FreeCategory.Ob)::FreeCategory.Hom
  FreeCategory.id(A)
end

function ThCategory.compose(f::FreeCategory.Hom, g::FreeCategory.Hom; strict=true)
  associate_unit(FreeCategory.compose(f, g; strict), id)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/models/SymbolicModels.jl#L92-L225">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils" href="#GATlab.Util.MetaUtils"><code>GATlab.Util.MetaUtils</code></a> — <span class="docstring-category">Module</span></header><section><div><p>General-purpose tools for metaprogramming in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}" href="#GATlab.Util.MetaUtils.generate_docstring-Tuple{Expr, Union{Nothing, String}}"><code>GATlab.Util.MetaUtils.generate_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap Julia expression with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.generate_function-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.generate_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate Julia expression for function definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_docstring-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_docstring</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia expression that is (possibly) annotated with docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function-Tuple{Expr}" href="#GATlab.Util.MetaUtils.parse_function-Tuple{Expr}"><code>GATlab.Util.MetaUtils.parse_function</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse Julia function definition into standardized form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}" href="#GATlab.Util.MetaUtils.parse_function_sig-Tuple{JuliaFunction}"><code>GATlab.Util.MetaUtils.parse_function_sig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse signature of Julia function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L107-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, Any}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occuring anywhere in a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L176-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}" href="#GATlab.Util.MetaUtils.replace_symbols-Tuple{AbstractDict, JuliaFunction}"><code>GATlab.Util.MetaUtils.replace_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replace symbols occurring anywhere in a Julia function (except the name).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L162-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}" href="#GATlab.Util.MetaUtils.strip_lines-Tuple{Expr}"><code>GATlab.Util.MetaUtils.strip_lines</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove all LineNumberNodes from a Julia expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/GATlab.jl/blob/d06ab566f6d4d0fa71decdcb056ab67ce2e606a2/src/util/MetaUtils.jl#L187-L189">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../concepts/models/">« Model families</a><a class="docs-footer-nextpage" href="../stdlib/">Standard Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Thursday 21 September 2023 00:18">Thursday 21 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
