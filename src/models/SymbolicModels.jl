module SymbolicModels
export GATExpr, @symbolic_model, SyntaxDomainError, head, args, gat_typeof, gat_type_args,
  functor, to_json_sexpr, parse_json_sexpr,
  show_sexpr, show_unicode, show_unicode_infix,
  show_latex, show_latex_infix, show_latex_postfix, show_latex_script

using ...Util
using ...Syntax
import ...Syntax: invoke_term

using Base.Meta: ParseError
using MLStyle

# Data types
############

""" Base type for expressions in the syntax of a GAT. This is an alternative
to `AlgTerm` used for backwards compatibility with Catlab.

We define Julia types for each *type constructor* in the theory, e.g., object,
morphism, and 2-morphism in the theory of 2-categories. Of course, Julia's
type system does not support dependent types, so the type parameters are
incorporated in the Julia types. (They are stored as extra data in the
expression instances.)

The concrete types are structurally similar to the core type `Expr` in Julia.
However, the *term constructor* is represented as a type parameter, rather than
as a `head` field. This makes dispatch using Julia's type system more
convenient.
"""
abstract type GATExpr{T} end

head(::GATExpr{T}) where T = T
args(expr::GATExpr) = expr.args
Base.first(expr::GATExpr) = first(args(expr))
Base.last(expr::GATExpr) = last(args(expr))
gat_typeof(expr::GATExpr) = nameof(typeof(expr))
gat_type_args(expr::GATExpr) = expr.type_args


""" Get name of GAT generator expression as a `Symbol`.

If the generator has no name, returns `nothing`.
"""
function Base.nameof(expr::GATExpr{:generator})
  name = first(expr)
  isnothing(name) ? nothing : Symbol(name)
end

function Base.:(==)(e1::GATExpr{T}, e2::GATExpr{S}) where {T,S}
  T == S && e1.args == e2.args && e1.type_args == e2.type_args
end

function Base.hash(e::GATExpr, h::UInt)
  hash(args(e), hash(head(e), h))
end

function Base.show(io::IO, expr::GATExpr)
  print(io, head(expr))
  print(io, "(")
  join(io, args(expr), ",")
  print(io, ")")
end

function Base.show(io::IO, expr::GATExpr{:generator})
  print(io, first(expr))
end

function Base.show(io::IO, ::MIME"text/plain", expr::GATExpr)
  show_unicode(io, expr)
end

function Base.show(io::IO, ::MIME"text/latex", expr::GATExpr)
  print(io, "\$")
  show_latex(io, expr)
  print(io, "\$")
end

struct SyntaxDomainError <: Exception
  constructor::Symbol
  args::Vector
end

function Base.showerror(io::IO, exc::SyntaxDomainError)
  print(io, "Domain error in term constructor $(exc.constructor)(")
  join(io, exc.args, ",")
  print(io, ")")
end

# Syntax
########
"""
@symbolic_model generates the free model of a theory, generated by
symbols.

This is backwards compatible with the @syntax macro in Catlab.

One way of thinking about this is that for every type constructor, we
add an additional term constructor that builds a "symbolic" element
of that type from any Julia value. This term constructor is called "generator".

An invocation of `@symbolic_model` creates the following.

1. A module with a struct for each type constructor, which has a single type
parameter `T` and two fields, `args` and `type_args`. Instances of this struct
are thought of as elements of the type given by the type constructor applied to
`type_args`. The type parameter refers to the term constructor that was used
to generate the element, including the special term constructor `:generator`,
which has as its single argument an `Any`.

For instance, in the theory of categories, we might have the following elements.

```
using .FreeCategory
x = Ob{:generator}([:x], [])
y = Ob{:generator}([:y], [])
f = Hom{:generator}([:f], [x, y])
g = Hom{:generator}([:g], [y, x])
h = Hom{:compose}([f, g], [x, x])
```

2. Methods inside the module (not exported) for all of the term constructors and
field accessors (i.e. stuff like `compose, id, dom, codom`), which construct terms.

3. A default instance (i.e., without a model parameter) of the theory using the
types in this generated model. Methods in this instance can be overridden by
the body of `@symbolic_model` to perform rewriting for the sake of normalization,
for instance flattening associative and unital operations.

4. Coercion methods of the type constructors that allow one to introduce generators.

```
x = ThCategory.Ob(FreeCategory.Ob, :x)
y = ThCategory.Ob(FreeCategory.Ob, :y)
f = ThCategory.Hom(:f, x, y)
```

Note that in both the instance and in these coercion methods, we must give the
expected type as the first argument when it cannot be infered by the other arguments.
For instance, instead of

```
munit() = ...
```

we have

```
munit(::Type{FreeSMC.Ob}) = ...
```

and likewise instead of

```
ThCategory.Ob(x::Any) = ...
```

we have

```
ThCategory.Ob(::Type{FreeCategory.Ob}, x::Any) = ...
```

Example:

```julia
@symbolic_model FreeCategory{ObExr, HomExpr} ThCategory begin
  compose(f::Hom, g::Hom) = associate_unit(new(f,g; strict=true), id)
end
```

This generates:

```julia
module FreeCategory
export Ob, Hom
using ..__module__

const THEORY_MODULE = ThCategory

struct Ob{T} <: __module__.ObExpr{T} # T is :generator or a Symbol
  args::Vector
  type_args::Vector{GATExpr}
end

struct Hom{T} <: __module__.HomExpr{T}
  args::Vector
  type_args::Vector{GATExpr}
end

dom(x::Hom) = x.type_args[1]

codom(x::Hom) = x.type_args[2]

function compose(f::Hom, g::Hom; strict=true)
  if strict && !(codom(f) == dom(g))
    throw(SyntaxDomainError(:compose, [f, g]))
  end
  Hom{:compose}([f, g], [dom(f), codom(g)])
end

function id(x::Ob)
  Ob{:id}([x], [x, x])
end
end

# default implementations 

function ThCategory.dom(x::FreeCategory.Hom)::FreeCategory.Ob
  FreeCategory.dom(x)
end

function ThCategory.Ob(::Type{FreeCategory.Ob}, __value__::Any)::FreeCategory.Ob
  FreeCategory.Ob{:generator}([__value__], [])
end

function ThCategory.id(A::FreeCategory.Ob)::FreeCategory.Hom
  FreeCategory.id(A)
end

function ThCategory.compose(f::FreeCategory.Hom, g::FreeCategory.Hom; strict=true)
  associate_unit(FreeCategory.compose(f, g; strict), id)
end
```
"""
macro symbolic_model(decl, theoryname, body)
  # Part 0: Parsing input
  
  theory = macroexpand(__module__, :($theoryname.@theory))
  
  (name, abstract_types) = @match decl begin
    Expr(:curly, name, abstract_types...) => (name, abstract_types)
    _ => throw(ParseError("Ill-formed head of @symbolic_model $decl"))
  end

  overrides = Dict{Ident, JuliaFunction}()

  if !isnothing(body)
    body.head == :block || error("expected a block as the body of @symbolic_model")

    for line in body.args
      if line isa LineNumberNode
        continue
      end
      f = parse_function(line)
      juliasig = parse_function_sig(f)
      decl = ident(theory; name=juliasig.name)
      sig = fromexpr.(Ref(Presentation(theory)), juliasig.types, Ref(AlgSort))
      method = resolvemethod(theory.resolvers[decl], sig)
      overrides[method] = f
    end
  end

  theorymodule = :($__module__.$theoryname)

  # Part 1: Generating structs

  module_structs = symbolic_structs(theory, abstract_types, __module__)
  
  # Part 2: Generating internal methods

  module_methods = [internal_accessors(theory)..., 
                    internal_constructors(theory)...]

  module_decl = :(module $(esc(name))
    export $(nameof.(sorts(theory))...)
    using ..($(nameof(__module__)))
    import ..($(nameof(__module__))): $theoryname
    const $(esc(:THEORY_MODULE)) = $(esc(theoryname))

    $(module_structs...)
    $(generate_function.(module_methods)...)
  end)

  # Part 3: Generating instance of theory
  theory_overloads = symbolic_instance_methods(theory, theoryname, name, overrides)

  # Part 4: Generating generators.

  generator_overloads = []
  # generator_overloads = symbolic_generators(theorymodule, theory)

  Expr(
    :toplevel,
    module_decl,
    :(Core.@__doc__ $(esc(name))),
    esc.(generate_function.([theory_overloads; generator_overloads]))...,
  )
end

function symbolic_struct(name, abstract_type, parentmod)::Expr
  quote
    struct $(esc(name)){T} <: $parentmod.$(abstract_type){T}
      args::$(Vector)
      type_args::$(Vector){$(GlobalRef(SymbolicModels, :GATExpr))}
    end
  end
end

function symbolic_structs(theory::GAT, abstract_types, parentmod)::Vector{Expr}
  map(zip(theory.sorts, abstract_types)) do (X, abstract_type)
    symbolic_struct(nameof(X), abstract_type, parentmod)
  end
end

function typename(theory::GAT, type::AlgType; parentmod=nothing)
  name = nameof(type.body.head)
  if !isnothing(parentmod)
    Expr(:(.), parentmod, QuoteNode(name))
  else
    esc(name)
  end
end

function internal_accessors(theory::GAT)
  map(theory.sorts) do sort
    typecon = getvalue(theory[sort.method])
    map(collect(pairs(theory.accessors[sort.method]))) do (i, acc)
      accessor = getvalue(theory[acc])
      return_type = getvalue(typecon[typecon.args[i]])
      JuliaFunction(
        name=esc(nameof(getdecl(accessor))),
        args=[:(x::$(esc(nameof(sort.head))))],
        return_type = typename(theory, return_type),
        impl=:(x.type_args[$i])
      )
    end
  end |> Iterators.flatten
end

function internal_constructors(theory::GAT)::Vector{JuliaFunction}
  map(termcons(theory)) do (decl, method)
    name = nameof(decl)
    termcon = getvalue(theory, method)
    args = map(argsof(termcon)) do binding 
      Expr(:(::), nameof(binding), typename(theory, getvalue(binding)))
    end  

    eqs = equations(theory, method)

    throw_expr = Expr(
      :call,
      throw,
      Expr(
        :call,
        SyntaxDomainError,
        Expr(:quote, name),
        Expr(:vect, nameof.(argsof(termcon))...)
      )
    )

    arg_expr_lookup = Dict{Ident, Any}(map(termcon.args) do lid
      x = ident(termcon.localcontext; lid)
      x => nameof(x)
    end)

    check_expr = Expr(
      :&&,
      map(filter(exprs -> length(exprs) > 1, collect(values(eqs)))) do exprs
        cmp_expr = []
        for e in exprs 
          append!(cmp_expr, [compile(arg_expr_lookup, e), esc(:(==))])
        end
        Expr(:comparison, cmp_expr[1:end-1]...)
      end...
    )

    check_or_error = Expr(:(||), :(!strict), check_expr, throw_expr)
    context_xs = getidents(termcon.localcontext)
    expr_lookup = Dict{Ident, Any}(map(context_xs) do x
      x => compile(arg_expr_lookup, first(eqs[x]))
    end)

    build = Expr(
      :call,
      Expr(:curly, typename(theory, termcon.type), Expr(:quote, name)),
      Expr(:vect, nameof.(argsof(termcon))...),
      Expr(:ref, GATExpr, compile.(Ref(expr_lookup), termcon.type.body.args)...)
    )

    JuliaFunction(
      ;name=esc(name),
      args=args,
      kwargs=[Expr(:kw, :strict, false)],
      impl=Expr(:block, check_or_error, build)
    )
  end
end 

macro symbolic_model(decl, theoryname)
  esc(:(@symbolic_model $decl $theoryname $nothing))
end

"""Julia function for every type constructor, accessor, and term constructor.
Term constructors can be overwritten by `overrides`. """
function symbolic_instance_methods(
  theory::GAT, theorymodule, syntaxname::Symbol, 
  overrides::Dict{Ident, JuliaFunction})::Vector{JuliaFunction}

  type_con_funs = []
  accessors_funs = []
  for sort in sorts(theory)
    type_con = getvalue(theory[sort.method])
    symgen = symbolic_generator(theorymodule, syntaxname, sort.method, type_con, theory)
    push!(type_con_funs, symgen)
    for binding in argsof(type_con)
      push!(accessors_funs, symbolic_accessor(theorymodule, theory, syntaxname, sort.method, binding))
    end
  end

  type_replacements = [
    nameof(X) => Expr(:(.), syntaxname, QuoteNode(nameof(X))) for X in sorts(theory)
  ]

  term_con_funs = map(termcons(theory)) do (decl, method)
    if haskey(overrides, method)
      replace_symbols(
        Dict([
          :new => Expr(:(.), syntaxname, QuoteNode(nameof(decl))); type_replacements
        ]),
        setname(overrides[method], Expr(:(.), theorymodule, QuoteNode(nameof(decl))))
      )
    else
      symbolic_termcon(theorymodule, theory, syntaxname, method)
    end
  end
  [type_con_funs..., accessors_funs..., term_con_funs...]
end


function symbolic_generator(theorymodule, syntaxname, X::Ident, typecon::AlgTypeConstructor, theory::GAT)
  value_param = gensym(:value)
  name = nameof(getdecl(typecon))
  args = [
    Expr(:(::), value_param, Any);
    [Expr(:(::), nameof(binding), typename(theory, getvalue(binding); parentmod=syntaxname))
     for binding in argsof(typecon)]
  ]

  if isempty(typecon.args)
    args = [Expr(:(::), Expr(:curly, Type, Expr(:(.), syntaxname, QuoteNode(name)))); args]
  end
  impl = quote 
    $(Expr(:(.), syntaxname, QuoteNode(name))){:generator}(
    $(Expr(:vect, value_param, nameof.(argsof(typecon))...)),
    $(Expr(:ref, GATExpr, nameof.(argsof(typecon))...))
  )
  end
  JuliaFunction(name=Expr(:(.), theorymodule, QuoteNode(name)), args=args,impl=impl )
end

function symbolic_accessor(theorymodule, theory, name, typecon::Ident, accessor::Binding)
  typcon_name = QuoteNode(nameof(getdecl(getvalue(theory[typecon]))))
  accessor_name = QuoteNode(nameof(accessor))
  JuliaFunction(
    name=Expr(:(.), theorymodule, accessor_name),
    args=[:(x::$(Expr(:(.), name, typcon_name)))],
    return_type = typename(theory, getvalue(accessor); parentmod=name),
    impl=Expr(:call, Expr(:(.), name, accessor_name), :x)
  )
end

function symbolic_termcon(theorymodule, theory, syntaxname, method::Ident)
  termcon = getvalue(theory[method])
  termcon_name = QuoteNode(nameof(getdecl(termcon)))
  return_type = typename(theory, termcon.type; parentmod=syntaxname)
  args = if !isempty(termcon.args)
    map(argsof(termcon)) do argbinding
      type = typename(theory, getvalue(argbinding); parentmod=syntaxname)
      Expr(:(::), nameof(argbinding), type)
    end
  else
    [Expr(:(::), Expr(:curly, Type, return_type))]
  end
  JuliaFunction(
    name=Expr(:(.), theorymodule, termcon_name),
    args=args,
    return_type=return_type,
    impl=Expr(:call, Expr(:(.), syntaxname, termcon_name), nameof.(argsof(termcon))...)
  )
end


# Reflection
############

function invoke_term(syntax_module::Module, constructor_name::Symbol, args)
  theory_module = syntax_module.THEORY_MODULE
  theory = theory_module.THEORY
  syntax_types = Tuple(getfield(syntax_module, nameof(sort)) for sort in sorts(theory))
  invoke_term(theory_module, syntax_types, constructor_name, args)
end

""" Name of constructor that created expression.
"""
constructor_name(expr::GATExpr) = head(expr)
constructor_name(expr::GATExpr{:generator}) = gat_typeof(expr)

"""
Get syntax module of given expression.
"""
syntax_module(expr::GATExpr) = parentmodule(typeof(expr))

# Functors
##########

""" Functor from GAT expression to GAT instance.

Strictly speaking, we should call these "structure-preserving functors" or,
better, "model homomorphisms of GATs". But this is a category theory library,
so we'll go with the simpler "functor".

A functor is completely determined by its action on the generators. There are
several ways to specify this mapping:

  1. Specify a Julia instance type for each GAT type, using the required `types`
     tuple. For this to work, the generator constructors must be defined for the
     instance types.

  2. Explicitly map each generator term to an instance value, using the
     `generators` dictionary.

  3. For each GAT type (e.g., object and morphism), specify a function mapping
     generator terms of that type to an instance value, using the `terms`
     dictionary.

The `terms` dictionary can also be used for special handling of non-generator
expressions. One use case for this capability is defining forgetful functors,
which map non-generators to generators.

FIXME
"""
function functor(types::Tuple, expr::GATExpr;
                 generators::AbstractDict=Dict(), terms::AbstractDict=Dict())
  # Special case: look up a specific generator.
  if head(expr) == :generator && haskey(generators, expr)
    return generators[expr]
  end

  # Special case: look up by type of term (usually a generator).
  name = constructor_name(expr)
  if haskey(terms, name)
    return terms[name](expr)
  end

  # Otherwise, we need to call a term constructor (possibly for a generator).
  # Recursively evalute the arguments.
  term_args = []
  for arg in args(expr)
    if isa(arg, GATExpr)
      arg = functor(types, arg; generators=generators, terms=terms)
    end
    push!(term_args, arg)
  end

  # Invoke the constructor in the codomain category!
  theory_module = syntax_module(expr).THEORY_MODULE
  invoke_term(theory_module, types, name, term_args)
end

# Serialization
###############

""" Serialize expression as JSON-able S-expression.

The format is an S-expression encoded as JSON, e.g., "compose(f,g)" is
represented as ["compose", f, g].
"""
function to_json_sexpr(expr::GATExpr; by_reference::Function = x->false)
  if head(expr) == :generator && by_reference(first(expr))
    to_json_sexpr(first(expr))
  else
    [ string(constructor_name(expr));
      [ to_json_sexpr(arg; by_reference=by_reference) for arg in args(expr) ] ]
  end
end
to_json_sexpr(x::Union{Bool,Real,String,Nothing}; kw...) = x
to_json_sexpr(x; kw...) = string(x)

""" Deserialize expression from JSON-able S-expression.

If `symbols` is true (the default), strings are converted to symbols.
"""
function parse_json_sexpr(syntax_module::Module, sexpr;
    parse_head::Function = identity,
    parse_reference::Function = x->error("Loading terms by name is disabled"),
    parse_value::Function = identity,
    symbols::Bool = true,
  )
  theory_module = syntax_module.THEORY_MODULE
  theory = theory_module.THEORY
  type_lens = Dict(
    nameof(getdecl(getvalue(binding))) => length(getvalue(binding).args)
    for binding in [theory[sort.method] for sort in sorts(theory)]
  )

  function parse_impl(sexpr::Vector, ::Type{Val{:expr}})
    name = Symbol(parse_head(symbols ? Symbol(sexpr[1]) : sexpr[1]))
    nargs = length(sexpr) - 1
    args = map(enumerate(sexpr[2:end])) do (i, arg)
      arg_kind = ((i == 1 && get(type_lens, name, nothing) == nargs-1) ||
                  arg isa Union{Bool,Number,Nothing}) ? :value : :expr
      parse_impl(arg, Val{arg_kind})
    end
    invoke_term(syntax_module, name, args)
  end
  parse_impl(x, ::Type{Val{:value}}) = parse_value(x)
  parse_impl(x::String, ::Type{Val{:expr}}) =
    parse_reference(symbols ? Symbol(x) : x)
  parse_impl(x::String, ::Type{Val{:value}}) =
    parse_value(symbols ? Symbol(x) : x)

  parse_impl(sexpr, Val{:expr})
end

# Pretty-print
##############

""" Show the syntax expression as an S-expression.

Cf. the standard library function `Meta.show_sexpr`.
"""
show_sexpr(expr::GATExpr) = show_sexpr(stdout, expr)

function show_sexpr(io::IO, expr::GATExpr)
  if head(expr) == :generator
    print(io, repr(first(expr)))
  else
    print(io, "(")
    join(io, [string(head(expr));
              [sprint(show_sexpr, arg) for arg in args(expr)]], " ")
    print(io, ")")
  end
end

""" Show the expression in infix notation using Unicode symbols.
"""
show_unicode(expr::GATExpr) = show_unicode(stdout, expr)
show_unicode(io::IO, x::Any; kw...) = show(io, x)

function show_unicode(io::IO, expr::GATExpr; kw...)
  # By default, show in prefix notation.
  print(io, head(expr))
  print(io, "{")
  join(io, [sprint(show_unicode, arg) for arg in args(expr)], ",")
  print(io, "}")
end

function show_unicode(io::IO, expr::GATExpr{:generator}; kw...)
  print(io, first(expr))
end

function show_unicode_infix(io::IO, expr::GATExpr, op::String;
                            paren::Bool=false)
  show_unicode_paren(io, expr) = show_unicode(io, expr; paren=true)
  if (paren) print(io, "(") end
  join(io, [sprint(show_unicode_paren, arg) for arg in args(expr)], op)
  if (paren) print(io, ")") end
end

""" Show the expression in infix notation using LaTeX math.

Does *not* include `\$` or `\\[begin|end]{equation}` delimiters.
"""
show_latex(expr::GATExpr) = show_latex(stdout, expr)
show_latex(io::IO, sym::Symbol; kw...) = print(io, sym)
show_latex(io::IO, x::Any; kw...) = show(io, x)

function show_latex(io::IO, expr::GATExpr; kw...)
  # By default, show in prefix notation.
  print(io, "\\mathop{\\mathrm{$(head(expr))}}")
  print(io, "\\left[")
  join(io, [sprint(show_latex, arg) for arg in args(expr)], ",")
  print(io, "\\right]")
end

function show_latex(io::IO, expr::GATExpr{:generator}; kw...)
  # Try to be smart about using text or math mode.
  content = string(first(expr))
  if all(isletter, content) && length(content) > 1
    print(io, "\\mathrm{$content}")
  else
    print(io, content)
  end
end

function show_latex_infix(io::IO, expr::GATExpr, op::String;
                          paren::Bool=false, kw...)
  show_latex_paren(io, expr) = show_latex(io, expr, paren=true)
  sep = op == " " ? op : " $op "
  if (paren) print(io, "\\left(") end
  join(io, [sprint(show_latex_paren, arg) for arg in args(expr)], sep)
  if (paren) print(io, "\\right)") end
end

function show_latex_postfix(io::IO, expr::GATExpr, op::String; kw...)
  @assert length(args(expr)) == 1
  print(io, "{")
  show_latex(io, first(expr), paren=true)
  print(io, "}")
  print(io, op)
end

function show_latex_script(io::IO, expr::GATExpr, head::String;
                           super::Bool=false, kw...)
  print(io, head, super ? "^" : "_", "{")
  join(io, [sprint(show_latex, arg) for arg in args(expr)], ",")
  print(io, "}")
end

end
